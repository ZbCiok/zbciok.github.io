"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[3871],{7386:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"streams/apache-flink/Operators/windowing","title":"Windowing","description":"Windows","source":"@site/docs/streams/apache-flink/Operators/windowing.mdx","sourceDirName":"streams/apache-flink/Operators","slug":"/streams/apache-flink/Operators/windowing","permalink":"/docs/streams/apache-flink/Operators/windowing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":100,"frontMatter":{"sidebar_position":100},"sidebar":"tutorialSidebar","previous":{"title":"Operators","permalink":"/docs/apache-flink/operators"},"next":{"title":"Joining","permalink":"/docs/streams/apache-flink/Operators/joining"}}');var o=i(4848),t=i(8453);const a={sidebar_position:100},r="Windowing",d={},l=[{value:"<em><strong>Windows</strong></em>",id:"windows",level:4},{value:"Keyed Windows",id:"keyed-windows",level:2},{value:"Flink windowing implementation",id:"flink-windowing-implementation",level:3},{value:"Session Window",id:"session-window",level:3},{value:"<em><strong>Example</strong></em>",id:"example",level:4},{value:"Sliding Window",id:"sliding-window",level:3},{value:"<em><strong>Example</strong></em>",id:"example-1",level:4},{value:"Tumbling Windows",id:"tumbling-windows",level:3},{value:"<em><strong>Example</strong></em>",id:"example-2",level:4},{value:"Non-Keyed Windows",id:"non-keyed-windows",level:2}];function w(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"windowing",children:"Windowing"})}),"\n",(0,o.jsx)(n.h4,{id:"windows",children:(0,o.jsx)(n.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.20/docs/dev/datastream/operators/windows/",children:(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"Windows"})})})}),"\n",(0,o.jsx)(n.p,{children:"Windows are at the heart of processing infinite streams. Windows split the stream into \u201cbuckets\u201d of finite size, over which we can apply computations. This document focuses on how windowing is performed in Flink and how the programmer can benefit to the maximum from its offered functionality."}),"\n",(0,o.jsxs)(n.p,{children:["To tackle the infinite stream of incoming messages Flink implemented a concept called ",(0,o.jsx)(n.strong,{children:"windows"}),". So the idea is very simple, separate elements of infinite streams into streams of finite groups (windows) and then process these groups independently."]}),"\n",(0,o.jsx)(n.p,{children:"A \u201cWindow\u201d defines a finite set of elements on an unbounded stream over which we can apply computations. This set can be based on time, element counts, a combination of counts and time, or some custom logic to assign elements to windows."}),"\n",(0,o.jsx)(n.p,{children:"The general structure of a windowed Flink program is presented below. The first snippet refers to keyed streams, while the second to non-keyed ones."}),"\n",(0,o.jsx)(n.h2,{id:"keyed-windows",children:"Keyed Windows"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'stream\n       .keyBy(...)               <-  keyed versus non-keyed windows\n       .window(...)              <-  required: "assigner"\n      [.trigger(...)]            <-  optional: "trigger" (else default trigger)\n      [.evictor(...)]            <-  optional: "evictor" (else no evictor)\n      [.allowedLateness(...)]    <-  optional: "lateness" (else zero)\n      [.sideOutputLateData(...)] <-  optional: "output tag" (else no side output for late data)\n       .reduce/aggregate/apply()      <-  required: "function"\n      [.getSideOutput(...)]      <-  optional: "output tag"\n'})}),"\n",(0,o.jsx)(n.p,{children:"This operator not only groups the finite number of elements into windows but in each window, it also splits elements into logical streams. It groups elements to process in parallel. Let\u2019s take a look at an example."}),"\n",(0,o.jsx)("img",{src:"/img/streams/apache-flink/keyed-windows-01.png",width:"500",height:"250",alt:"keyed-windows-01.png"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.h3,{id:"flink-windowing-implementation",children:"Flink windowing implementation"}),"\n",(0,o.jsx)(n.p,{children:"Flink implements windowing using two main components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"window assigner"}),": responsible for assigning each event to one or more windows based on some criteria (e.g., time or count)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"window operator"}),": responsible for managing the state of each window (e.g., storing the events or intermediate results), applying triggers and evictors, and executing window functions"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Flink\u2019s windowing implementation is based on two key concepts:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"event time"}),": is the logical time at which an event occurred in the real world, as opposed to the processing time at which an event arrived at a system component"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"watermarks"}),": are special events that carry information about the progress of event time in a stream. Watermarks are used by Flink to determine when a window can be closed and processed, based on the assumption that no events with a lower timestamp will arrive after a watermark"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"To define a window on a stream, you need to specify three components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"window assigner"}),": this determines how the events are assigned to windows. Flink provides built-in window assigners for the four types of keyed windows and the two types of non-keyed windows, as well as a generic window assigner that allows you to define your own custom windows"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"window trigger"}),": this determines when a window is ready to be processed and emitted. Flink provides built-in triggers for event time and processing time, as well as a generic trigger that allows you to define your own custom triggers"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"window"})," function: this determines how the events in a window are processed and aggregated. Flink provides built-in window functions for common operations, such as sum, count, min, max, and reduce, as well as a generic window function that allows you to define your own custom logic"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In addition to these components, you can also specify two optional components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"window evictor"}),": this determines how the events are evicted from a window after they have been processed. Flink provides built-in evictors for count-based and time-based eviction, as well as a generic evictor that allows you to define your own custom eviction logic"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"allowed lateness"}),": this determines how late events are handled after a window has been emitted. Flink allows you to specify a grace period for late events, and either discard them or update the previous results"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"session-window",children:"Session Window"}),"\n",(0,o.jsx)(n.p,{children:"It\u2019s a dynamic-sized windows that group events based on session activity. A session window closes when there is a gap of inactivity that exceeds a specified threshold. For example, if you define a session window with a gap of 10 minutes, the stream will be divided into windows that contain events that are at most 10 minutes apart from each other."}),"\n",(0,o.jsx)(n.p,{children:"Session windows do not overlap and do not have a fixed start and end time. A session window assigner can be configured with either a static session gap or with a session gap extractor function which defines how long the period of inactivity is."}),"\n",(0,o.jsx)(n.p,{children:"The Session windows assigner groups elements by sessions of activity. Session windows do not overlap and do not have a fixed start and end time. The number of entities within a session window is not fixed. Because it is a user who defines typically how long the session would be. A session window closes when it does not receive elements for a certain period of time, i.e., when a gap of inactivity occurred. For example, once we have been idle on the amazon website let say for 1 minute that is the end of the previous session and if go back to the site after 1 sec it will start a new session. The way it would determine the session is the pause between one click and another click."}),"\n",(0,o.jsx)("img",{src:"/img/streams/apache-flink/session-window-01.png",width:"500",height:"200",alt:"session-window-01.png"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"input // a stream of key-value pairs\n  .keyBy(0) // partition the stream by the first field (key)\n  .window(EventTimeSessionWindows.withGap(Time.minutes(5))) // assign a session window with a 5-minute gap duration based on event time\n  .process(new DeduplicateProcessFunction()) // filter out duplicate values per key in each window using a custom process function\n  .print(); // print the results to standard output\n"})}),"\n",(0,o.jsx)(n.h4,{id:"example",children:(0,o.jsx)(n.a,{href:"/docs/streams/apache-flink/Examples/session-window",children:(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"Example"})})})}),"\n",(0,o.jsx)(n.h3,{id:"sliding-window",children:"Sliding Window"}),"\n",(0,o.jsxs)(n.p,{children:["The sliding windows assigner assigns elements to windows of fixed length. It is defined by two time durations, a ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"width"})})," for each window and a ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"slide"})})," that designates the time between the start of consecutive windows. Typically the slide is less than the window. A sliding window can be used to provide a view of data over some lookback time (the width), updated with some frequency (the slide)."]}),"\n",(0,o.jsx)("img",{src:"/img/streams/apache-flink/sliding-window-01.png",width:"500",height:"100",alt:"sliding-window-01.png"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"An example sliding window with width=5 minutes and slide=3 minutes."})})}),"\n",(0,o.jsx)(n.p,{children:"The following code snippets show how to use sliding windows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"DataStream<T> input = ...;\n\n// sliding event-time windows\ninput\n    .keyBy(<key selector>)\n    .window(SlidingEventTimeWindows.of(Duration.ofSeconds(10), Duration.ofSeconds(5)))\n    .<windowed transformation>(<window function>);\n\n// sliding processing-time windows\ninput\n    .keyBy(<key selector>)\n    .window(SlidingProcessingTimeWindows.of(Duration.ofSeconds(10), Duration.ofSeconds(5)))\n    .<windowed transformation>(<window function>);\n\n// sliding processing-time windows offset by -8 hours\ninput\n    .keyBy(<key selector>)\n    .window(SlidingProcessingTimeWindows.of(Duration.ofHours(12), Duration.ofHours(1), Duration.ofHours(-8)))\n    .<windowed transformation>(<window function>);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"example-1",children:(0,o.jsx)(n.a,{href:"/docs/streams/apache-flink/Examples/sliding-window",children:(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"Example"})})})}),"\n",(0,o.jsx)(n.h3,{id:"tumbling-windows",children:"Tumbling Windows"}),"\n",(0,o.jsx)(n.p,{children:"A tumbling windows assigner assigns each element to a window of a specified window size. Tumbling windows have a fixed size and do not overlap. For example, if you specify a tumbling window with a size of 5 minutes, the current window will be evaluated and a new window will be started every five minutes as illustrated by the following figure."}),"\n",(0,o.jsx)("img",{src:"/img/streams/apache-flink/tumbling-window-01.png",width:"600",height:"150",alt:"tumbling-window-01.png"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.p,{children:"The following code snippets show how to use tumbling windows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"DataStream<T> input = ...;\n\n// tumbling event-time windows\ninput\n    .keyBy(<key selector>)\n    .window(TumblingEventTimeWindows.of(Duration.ofSeconds(5)))\n    .<windowed transformation>(<window function>);\n\n// tumbling processing-time windows\ninput\n    .keyBy(<key selector>)\n    .window(TumblingProcessingTimeWindows.of(Duration.ofSeconds(5)))\n    .<windowed transformation>(<window function>);\n\n// daily tumbling event-time windows offset by -8 hours.\ninput\n    .keyBy(<key selector>)\n    .window(TumblingEventTimeWindows.of(Duration.ofDays(1), Duration.ofHours(-8)))\n    .<windowed transformation>(<window function>);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"example-2",children:(0,o.jsx)(n.a,{href:"/docs/streams/apache-flink/Examples/tumbling-window",children:(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"Example"})})})}),"\n",(0,o.jsx)(n.h2,{id:"non-keyed-windows",children:"Non-Keyed Windows"}),"\n",(0,o.jsx)(n.p,{children:"Non keyed window simply separate elements of infinite streams into the stream of a finite group. It results in the non-parallel processing of a single stream. The syntax for non keyed window is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'stream\n       .windowAll(...)           <-  required: "assigner"\n      [.trigger(...)]            <-  optional: "trigger" (else default trigger)\n      [.evictor(...)]            <-  optional: "evictor" (else no evictor)\n      [.allowedLateness(...)]    <-  optional: "lateness" (else zero)\n      [.sideOutputLateData(...)] <-  optional: "output tag" (else no side output for late data)\n       .reduce/aggregate/apply()      <-  required: "function"\n      [.getSideOutput(...)]      <-  optional: "output tag"\n'})}),"\n",(0,o.jsx)(n.p,{children:"For non keyed window, we just need to call the windowAll(\u2026) method as shown below."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"//Non keyed window\nstream.windowAll(...)\n"})})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(w,{...e})}):w(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var s=i(6540);const o={},t=s.createContext(o);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);