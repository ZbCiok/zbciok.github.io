"use strict";(self.webpackChunkjreact_com_docsaurus=self.webpackChunkjreact_com_docsaurus||[]).push([[4677],{6393:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>c,toc:()=>l});var r=n(4848),i=n(8453);const t={slug:"/streams/reactive-streams/java-util-concurrent-Flow"},o="java.util.concurrent.Flow",c={id:"streams/reactive-streams/java-util-concurrent-Flow/index",title:"java.util.concurrent.Flow",description:"The Java Flow API, introduced in Java 9,",source:"@site/docs/streams/reactive-streams/java-util-concurrent-Flow/index.mdx",sourceDirName:"streams/reactive-streams/java-util-concurrent-Flow",slug:"/streams/reactive-streams/java-util-concurrent-Flow",permalink:"/docs/streams/reactive-streams/java-util-concurrent-Flow",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{slug:"/streams/reactive-streams/java-util-concurrent-Flow"},sidebar:"tutorialSidebar",previous:{title:"Reactive Streams",permalink:"/docs/reactive-streams"},next:{title:"Examples",permalink:"/docs/streams/reactive-streams/java-util-concurrent-Flow/examples"}},a={},l=[{value:"Class Flow",id:"class-flow",level:2},{value:"Key components:",id:"key-components",level:2},{value:"Publisher",id:"publisher",level:3},{value:"Subscriber",id:"subscriber",level:3},{value:"Subscription",id:"subscription",level:3},{value:"Processor",id:"processor",level:3},{value:"SubmissionPublisher",id:"submissionpublisher",level:3},{value:"Example: Flow.Publisher",id:"example-flowpublisher",level:2},{value:"Example: Flow.Subscriber",id:"example-flowsubscriber",level:2}];function u(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"javautilconcurrentflow",children:"java.util.concurrent.Flow"}),"\n",(0,r.jsxs)(s.p,{children:["The Java Flow API, introduced in Java 9,\nprovides a standard and efficient way for components of a reactive system to communicate with each other asynchronously,\nwithout requiring them to know each other's implementation details.",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.strong,{children:"Flow API enables us to adopt Reactive Programming using just the JDK, not needing additional libraries such as RxJava or Project Reactor, amongst others."})]}),"\n",(0,r.jsx)("img",{src:"/img/streams/reactive-streams/flow-api/Java-9-Flow-Simiplified-Communication-Flow.png",alt:"java-9-flow-api-operations-01.png"}),"\n",(0,r.jsx)(s.h2,{id:"class-flow",children:(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.html",children:"Class Flow"})}),"\n",(0,r.jsxs)(s.p,{children:["Interrelated interfaces and static methods for establishing flow-controlled components in which ",(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.Publisher.html",children:(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Publishers"})})})})," produce items consumed by one or more ",(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.Subscriber.html",children:(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Subscribers"})})})}),",\neach managed by a ",(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.Subscription.html",children:(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Subscription"})})})}),"."]}),"\n",(0,r.jsx)(s.p,{children:'These interfaces correspond to the reactive-streams specification. They apply in both concurrent and distributed asynchronous settings: All (seven) methods are defined in void "one-way" message style. Communication relies on a simple form of flow control (method Flow.Subscription.request(long)) that can be used to avoid resource management problems that may otherwise occur in "push" based systems.'}),"\n",(0,r.jsx)(s.h2,{id:"key-components",children:"Key components:"}),"\n",(0,r.jsx)(s.h3,{id:"publisher",children:(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.Publisher.html",children:"Publisher"})}),"\n",(0,r.jsx)("img",{src:"/img/streams/reactive-streams/flow-api/java-9-flow-api-publisher-02.png",alt:"flow-publisher"}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.p,{children:"A Publisher is a provider of data items, which publishes them to one or more Subscriber instances.\nTo implement a custom Publisher, you need to implement the java.util.concurrent.Flow.Publisher interface,\nwhich defines the following methods:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"    subscribe(Subscriber<? super T> subscriber)"}),": Subscribes a Subscriber to this Publisher,\nreturning a new Subscription instance that represents the connection between them."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"subscriber",children:(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.Subscriber.html",children:"Subscriber"})}),"\n",(0,r.jsx)("img",{src:"/img/streams/reactive-streams/flow-api/java-9-flow-api-subscriber-02.png",alt:"flow-publisher"}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(s.p,{children:"A Subscriber is a consumer of data items, which receives them from a Publisher.\nTo implement a custom Subscriber, you need to implement the java.util.concurrent.Flow.Subscriber interface,\nwhich defines the following methods:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"onSubscribe(Subscription subscription)"}),": Receives a Subscription instance from the Publisher,\nwhich allows the Subscriber to request and receive data items from the Publisher."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"onNext(T item)"}),": Receives the next data item from the Publisher."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"onError(Throwable throwable)"}),": Receives an error notification from the Publisher."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"onComplete()"}),": Receives a completion notification from the Publisher."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"subscription",children:(0,r.jsx)(s.a,{href:"https://docs.oracle.com/en%2Fjava%2Fjavase%2F11%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/Flow.Subscription.html",children:"Subscription"})}),"\n",(0,r.jsx)(s.p,{children:"A Subscription is a connection between a Publisher and a Subscriber, which allows the Subscriber to request and receive data items from the Publisher.\nTo implement a custom Subscription, you need to implement the java.util.concurrent.Flow.Subscription interface, which defines the following methods:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"request(long n)"}),": Requests n data items from the Publisher."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"cancel()"}),": Cancels the Subscription, terminating the connection between the Publisher and Subscriber."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"processor",children:(0,r.jsx)(s.a,{href:"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Processor.html",children:"Processor"})}),"\n",(0,r.jsx)(s.p,{children:"A Processor is a component that both subscribes to a Publisher and publishes to a Subscriber,\nallowing it to transform or filter data items.\nTo implement a custom Processor, you need to implement both the java.util.concurrent.Flow.Publisher and java.util.concurrent.Flow.Subscriber interfaces."}),"\n",(0,r.jsx)(s.h3,{id:"submissionpublisher",children:(0,r.jsx)(s.a,{href:"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/SubmissionPublisher.html",children:"SubmissionPublisher"})}),"\n",(0,r.jsxs)(s.p,{children:["Since Java 9, we can create ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Reactive Streams"})})})," by introducing four core interfaces:\n",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Publisher"})})}),", ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Subscriber"})})}),", ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Subscription"})})}),", ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Processor"})})}),", and one concrete class: ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"SubmissionPublisher"})})})," that implements the ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.strong,{children:"Publisher"})})})," interface.\nEach interface plays a different role, corresponding to the principles of Reactive Streams.\nWe can use the submit() method of SubmissionPublisher class to publish the provided item to each subscriber."]}),"\n",(0,r.jsx)(s.h2,{id:"example-flowpublisher",children:"Example: Flow.Publisher"}),"\n",(0,r.jsx)(s.p,{children:"A Flow.Publisher usually defines its own Flow.Subscription implementation; constructing one in method subscribe and issuing it to the calling Flow.Subscriber.\nIt publishes items to the subscriber asynchronously, normally using an Executor. For example, here is a very simple publisher that only issues (when requested) a single TRUE item to a single subscriber. Because the subscriber receives only a single item,\nthis class does not use buffering and ordering control required in most implementations (for example SubmissionPublisher)."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:" class OneShotPublisher implements Publisher<Boolean> {\n   private final ExecutorService executor = ForkJoinPool.commonPool(); // daemon-based\n   private boolean subscribed; // true after first subscribe\n   public synchronized void subscribe(Subscriber<? super Boolean> subscriber) {\n     if (subscribed)\n       subscriber.onError(new IllegalStateException()); // only one allowed\n     else {\n       subscribed = true;\n       subscriber.onSubscribe(new OneShotSubscription(subscriber, executor));\n     }\n   }\n   static class OneShotSubscription implements Subscription {\n     private final Subscriber<? super Boolean> subscriber;\n     private final ExecutorService executor;\n     private Future<?> future; // to allow cancellation\n     private boolean completed;\n     OneShotSubscription(Subscriber<? super Boolean> subscriber,\n                         ExecutorService executor) {\n       this.subscriber = subscriber;\n       this.executor = executor;\n     }\n     public synchronized void request(long n) {\n       if (!completed) {\n         completed = true;\n         if (n <= 0) {\n           IllegalArgumentException ex = new IllegalArgumentException();\n           executor.execute(() -> subscriber.onError(ex));\n         } else {\n           future = executor.submit(() -> {\n             subscriber.onNext(Boolean.TRUE);\n             subscriber.onComplete();\n           });\n         }\n       }\n     }\n     public synchronized void cancel() {\n       completed = true;\n       if (future != null) future.cancel(false);\n     }\n   }\n }\n"})}),"\n",(0,r.jsx)(s.h2,{id:"example-flowsubscriber",children:"Example: Flow.Subscriber"}),"\n",(0,r.jsx)(s.p,{children:"A Flow.Subscriber arranges that items be requested and processed. Items (invocations of Flow.Subscriber.onNext(T)) are not issued unless requested, but multiple items may be requested.\nMany Subscriber implementations can arrange this in the style of the following example, where a buffer size of 1 single-steps, and larger sizes usually allow for more efficient overlapped processing with less communication; for example with a value of 64, this keeps total outstanding requests between 32 and 64. Because Subscriber method invocations for a given Flow.Subscription are strictly ordered,\nthere is no need for these methods to use locks or volatiles unless a Subscriber maintains multiple Subscriptions (in which case it is better to instead define multiple Subscribers, each with its own Subscription)."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:" class SampleSubscriber<T> implements Subscriber<T> {\n   final Consumer<? super T> consumer;\n   Subscription subscription;\n   final long bufferSize;\n   long count;\n   SampleSubscriber(long bufferSize, Consumer<? super T> consumer) {\n     this.bufferSize = bufferSize;\n     this.consumer = consumer;\n   }\n   public void onSubscribe(Subscription subscription) {\n     long initialRequestSize = bufferSize;\n     count = bufferSize - bufferSize / 2; // re-request when half consumed\n     (this.subscription = subscription).request(initialRequestSize);\n   }\n   public void onNext(T item) {\n     if (--count <= 0)\n       subscription.request(count = bufferSize - bufferSize / 2);\n     consumer.accept(item);\n   }\n   public void onError(Throwable ex) { ex.printStackTrace(); }\n   public void onComplete() {}\n }\n"})}),"\n",(0,r.jsx)(s.p,{children:"The default value of defaultBufferSize() may provide a useful starting point for choosing request sizes and capacities in Flow components based on expected rates, resources, and usages. Or, when flow control is never needed, a subscriber may initially request an effectively unbounded number of items, as in:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:" class UnboundedSubscriber<T> implements Subscriber<T> {\n   public void onSubscribe(Subscription subscription) {\n     subscription.request(Long.MAX_VALUE); // effectively unbounded\n   }\n   public void onNext(T item) { use(item); }\n   public void onError(Throwable ex) { ex.printStackTrace(); }\n   public void onComplete() {}\n   void use(T item) { ... }\n }\n"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var r=n(6540);const i={},t=r.createContext(i);function o(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);