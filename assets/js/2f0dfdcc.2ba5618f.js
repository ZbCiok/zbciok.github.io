"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[8095],{7967:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>h,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var s=t(4848),r=t(8453),i=t(3514),a=t(5068);const o={slug:"/messaging/rabbitmq"},h="RabbitMQ",c={id:"messaging/rabbitmq/index",title:"RabbitMQ",description:"https://www.rabbitmq.com/",source:"@site/docs/messaging/rabbitmq/index.mdx",sourceDirName:"messaging/rabbitmq",slug:"/messaging/rabbitmq",permalink:"/docs/messaging/rabbitmq",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{slug:"/messaging/rabbitmq"},sidebar:"tutorialSidebar",previous:{title:"References",permalink:"/docs/messaging/kafka/references"},next:{title:"Docker RabbitMQ",permalink:"/docs/messaging/rabbitmq/docker-rabbitmq"}},l={},d=[{value:"Terminology",id:"terminology",level:2},{value:"Queue",id:"queue",level:2},{value:"Exchanges",id:"exchanges",level:2},{value:"Direct Exchange",id:"direct-exchange",level:3},{value:"Topic Exchange",id:"topic-exchange",level:3},{value:"Routing patterns in Topic Exchange",id:"routing-patterns-in-topic-exchange",level:4},{value:"Headers Exchange",id:"headers-exchange",level:3},{value:"The Headers matching algorithm",id:"the-headers-matching-algorithm",level:4},{value:"Fanout Exchange",id:"fanout-exchange",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"rabbitmq",children:"RabbitMQ"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://www.rabbitmq.com/",children:"https://www.rabbitmq.com/"})})})," ",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.a,{href:"https://www.rabbitmq.com/tutorials",children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"RabbitMQ Tutorials"})})})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Producer: Application that sends the messages."}),"\n",(0,s.jsx)(n.li,{children:"Consumer: Application that receives the messages."}),"\n",(0,s.jsx)(n.li,{children:"Queue: Buffer that stores messages."}),"\n",(0,s.jsx)(n.li,{children:"Message: Information that is sent from the producer to a consumer through RabbitMQ."}),"\n",(0,s.jsx)(n.li,{children:"Connection: A connection is a TCP connection between your application and the RabbitMQ broker."}),"\n",(0,s.jsx)(n.li,{children:"Channel: A channel is a virtual connection inside a connection. When you are publishing or consuming messages from a queue \u2013 it\u2019s all done over a channel."}),"\n",(0,s.jsx)(n.li,{children:"Exchange: Receives messages from producers and pushes them to queues depending on rules defined by the exchange type. To receive messages, a queue needs to be bound to at least one exchange."}),"\n",(0,s.jsx)(n.li,{children:"Binding: A binding is a link between a queue and an exchange."}),"\n",(0,s.jsx)(n.li,{children:"Routing key: The routing key is a key that the exchange looks at to decide how to route the message to queues. The routing key is like an address for the message."}),"\n"]}),"\n",(0,s.jsx)("img",{src:"/img/messaging/rabbitmq/rabbitm-multiple-queues.png",alt:"rabbitm-multiple-queues.png"}),"\n",(0,s.jsx)(n.h2,{id:"queue",children:"Queue"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Producer"})})," - a program that sends messages is a ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"producer"})})," (",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"P"})}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Queue"})})," - messages can be stored inside a ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Queue"})}),". Many ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"producers"})})," can send messages that go to one ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"queue"})}),", and many ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"consumers"})})," can try to receive data from one ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"queue"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Consumer"})})," - a ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"consumer"})})," (",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"C"})}),") is a program that mostly waits to receive messages."]}),"\n"]}),"\n",(0,s.jsx)("img",{src:"/img/messaging/rabbitmq/rabbitmq-queue-01.png",alt:"rabbitmq-queue-01.png"}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Exchange"})})," - on one side it receives messages from ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"producers"})})," and the other side it pushes them to ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"queues"})}),"."]}),"\n"]}),"\n",(0,s.jsx)("img",{src:"/img/messaging/rabbitmq/rabbitmq-exchange-01.png",alt:"rabbitmq-exchange-01.png"}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"exchange"})})," must know exactly what to do with a message it receives. Should it be appended to a particular ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"queue"})}),"? Should it be appended to many ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"queues"})}),"? Or should it get discarded. The rules for that are defined by the ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"exchange type"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"exchanges",children:"Exchanges"}),"\n",(0,s.jsxs)(n.p,{children:["RabbitMQ is a versatile message broker that enables complex routing scenarios between producers and consumers. It plays a pivotal role in modern software architectures, facilitating asynchronous communication and enhancing scalability. At the heart of RabbitMQ\u2019s power are its ",(0,s.jsx)(n.strong,{children:"exchanges, which control how messages are routed to queues"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Exchanges are RabbitMQ entities where messages are sent before arriving at queues. The type of exchange determines how a message is routed. There are four main types of exchanges in RabbitMQ:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"direct"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"topic"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"headers"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"fanout"})})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"direct-exchange",children:"Direct Exchange"}),"\n",(0,s.jsxs)(n.p,{children:["When a message is published to a direct exchange, it includes a ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"routing key"})})," \u2014 a string identifier. The exchange then forwards the message to all queues that are bound to it with a matching routing key. If no queue matches the routing key, the message is discarded (unless configured otherwise, such as returning the message to the producer or storing it in a dead letter queue)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Routing Key"})}),": A message attribute used by the exchange to route messages to the correct queue. It\u2019s like an address that tells the exchange where to deliver the message."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Binding Key"})}),": When a queue binds to an exchange, it specifies a binding key. It\u2019s this key that the exchange uses to match against the message\u2019s routing key."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"topic-exchange",children:"Topic Exchange"}),"\n",(0,s.jsx)(n.p,{children:"Topic exchanges route messages to queues based on wildcard matches between the routing key and the routing pattern, which is specified by the queue binding. Messages are routed to one or many queues based on a matching between a message routing key and this pattern."}),"\n",(0,s.jsxs)(n.p,{children:["The routing key must be a list of words, delimited by a period (.). Examples are agreements.us and agreements.eu.stockholm which in this case identifies agreements that are set up for a company with offices in lots of different locations. The routing patterns may contain an asterisk (\u201c",(0,s.jsx)(n.em,{children:'\u201d) to match a word in a specific position of the routing key (e.g., a routing pattern of "agreements.'}),".",(0,s.jsx)(n.em,{children:".b."}),'" only match routing keys where the first word is "agreements" and the fourth word is "b"). A pound symbol (\u201c#\u201d) indicates a match of zero or more words (e.g., a routing pattern of "agreements.eu.berlin.#" matches any routing keys beginning with "agreements.eu.berlin").']}),"\n",(0,s.jsx)(n.p,{children:"The consumers indicate which topics they are interested in (like subscribing to a feed for an individual tag). The consumer creates a queue and sets up a binding with a given routing pattern to the exchange. All messages with a routing key that match the routing pattern are routed to the queue and stay there until the consumer consumes the message."}),"\n",(0,s.jsx)(n.p,{children:'The default exchange AMQP brokers must provide for the topic exchange is "amq.topic".'}),"\n",(0,s.jsx)(n.h4,{id:"routing-patterns-in-topic-exchange",children:"Routing patterns in Topic Exchange"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A routing key in Topic Exchange must consist of Zero or more words delimited by dots e.g. health.education."}),"\n",(0,s.jsx)(n.li,{children:"A routing key in topic exchange is often called as a routing pattern."}),"\n",(0,s.jsx)(n.li,{children:"A routing pattern is like a regular expression with only *, . and # allowed."}),"\n",(0,s.jsx)(n.li,{children:"The symbol star (*) means exactly one word allowed."}),"\n",(0,s.jsx)(n.li,{children:"Similarly, the symbol hash (#) means zero or more number of words allowed."}),"\n",(0,s.jsx)(n.li,{children:"The symbol dot (.) means \u2013 word delimiter. Multiple key terms are separated by the dot delimiter."}),"\n",(0,s.jsx)(n.li,{children:"If a routing pattern is health.*, it means any message sent with the routing key health as the first word will reach the queue. For example, health.education will reach this Queue, but sports.health will not work."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"headers-exchange",children:"Headers Exchange"}),"\n",(0,s.jsx)(n.p,{children:"A headers exchange routes messages based on arguments containing headers and optional values. Headers exchanges are very similar to topic exchanges, but route messages based on header values instead of routing keys. A message matches if the value of the header equals the value specified upon binding."}),"\n",(0,s.jsx)(n.p,{children:'A special argument named "x-match", added in the binding between exchange and queue, specifies if all headers must match or just one. Either any common header between the message and the binding count as a match, or all the headers referenced in the binding need to be present in the message for it to match. The "x-match" property can have two different values: "any" or "all", where "all" is the default value. A value of "all" means all header pairs (key, value) must match, while value of "any" means at least one of the header pairs must match. Headers can be constructed using a wider range of data types, integer or hash for example, instead of a string. The headers exchange type (used with the binding argument "any") is useful for directing messages which contain a subset of known (unordered) criteria.'}),"\n",(0,s.jsx)(n.p,{children:'The default exchange AMQP brokers must provide for the topic exchange is "amq.headers".'}),"\n",(0,s.jsx)(n.h4,{id:"the-headers-matching-algorithm",children:"The Headers matching algorithm"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'- There are 2 types of headers matching allowed which are any (similar to logical OR) or all (similar to logical AND).\n- They are represented in the bindings as { "x-match", "any" ..} or { \u201cx-match\u201d, \u201call\u201d ..}.\n- The x-match = any means, a message sent to the Exchange should contain at least one of the headers that Queue is linked with, then the message will be routed to the Queue.\n- On the other hand, if a queue is bound with headers has x-match = all, messages that have all of its listed headers will be forwarded to the Queue.\n- You can see in the above diagram if a message with header {"h1": "Header1"} is sent to my-header-exchange, it will be routed to both HealthQ and EducationQ.\n- Only when the message has both the h1 and h2 headers with correct values, it will be forwarded to SportsQ, HealthQ and EducationQ as well.\n'})}),"\n",(0,s.jsx)(n.h3,{id:"fanout-exchange",children:"Fanout Exchange"}),"\n",(0,s.jsx)(n.p,{children:"A fanout exchange copies and routes a received message to all queues that are bound to it regardless of routing keys or pattern matching as with direct and topic exchanges. The keys provided will simply be ignored."}),"\n",(0,s.jsx)(n.p,{children:"Fanout exchanges can be useful when the same message needs to be sent to one or more queues with consumers who may process the same message in different ways."}),"\n",(0,s.jsx)(n.p,{children:"The image to the right (Fanout Exchange) shows an example where a message received by the exchange is copied and routed to all three queues bound to the exchange. It could be sport or weather updates that should be sent out to each connected mobile device when something happens, for instance."}),"\n",(0,s.jsx)(n.p,{children:'The default exchange AMQP brokers must provide for the topic exchange is "amq.fanout".'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)("br",{}),"\n","\n",(0,s.jsx)(i.A,{items:(0,a.$S)().items})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},3514:(e,n,t)=>{t.d(n,{A:()=>j});t(6540);var s=t(4164),r=t(6972),i=t(8774),a=t(5846),o=t(6654),h=t(1312),c=t(1107);const l={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var d=t(4848);function u(e){let{href:n,children:t}=e;return(0,d.jsx)(i.A,{href:n,className:(0,s.A)("card padding--lg",l.cardContainer),children:t})}function m(e){let{href:n,icon:t,title:r,description:i}=e;return(0,d.jsxs)(u,{href:n,children:[(0,d.jsxs)(c.A,{as:"h2",className:(0,s.A)("text--truncate",l.cardTitle),title:r,children:[t," ",r]}),i&&(0,d.jsx)("p",{className:(0,s.A)("text--truncate",l.cardDescription),title:i,children:i})]})}function g(e){let{item:n}=e;const t=(0,r.Nr)(n),s=function(){const{selectMessage:e}=(0,a.W)();return n=>e(n,(0,h.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:n}))}();return t?(0,d.jsx)(m,{href:t,icon:"\ud83d\uddc3\ufe0f",title:n.label,description:n.description??s(n.items.length)}):null}function x(e){let{item:n}=e;const t=(0,o.A)(n.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",s=(0,r.cC)(n.docId??void 0);return(0,d.jsx)(m,{href:n.href,icon:t,title:n.label,description:n.description??s?.description})}function p(e){let{item:n}=e;switch(n.type){case"link":return(0,d.jsx)(x,{item:n});case"category":return(0,d.jsx)(g,{item:n});default:throw new Error(`unknown item type ${JSON.stringify(n)}`)}}function b(e){let{className:n}=e;const t=(0,r.$S)();return(0,d.jsx)(j,{items:t.items,className:n})}function j(e){const{items:n,className:t}=e;if(!n)return(0,d.jsx)(b,{...e});const i=(0,r.d1)(n);return(0,d.jsx)("section",{className:(0,s.A)("row",t),children:i.map(((e,n)=>(0,d.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,d.jsx)(p,{item:e})},n)))})}},5846:(e,n,t)=>{t.d(n,{W:()=>c});var s=t(6540),r=t(4586);const i=["zero","one","two","few","many","other"];function a(e){return i.filter((n=>e.includes(n)))}const o={locale:"en",pluralForms:a(["one","other"]),select:e=>1===e?"one":"other"};function h(){const{i18n:{currentLocale:e}}=(0,r.A)();return(0,s.useMemo)((()=>{try{return function(e){const n=new Intl.PluralRules(e);return{locale:e,pluralForms:a(n.resolvedOptions().pluralCategories),select:e=>n.select(e)}}(e)}catch(n){return console.error(`Failed to use Intl.PluralRules for locale "${e}".\nDocusaurus will fallback to the default (English) implementation.\nError: ${n.message}\n`),o}}),[e])}function c(){const e=h();return{selectMessage:(n,t)=>function(e,n,t){const s=e.split("|");if(1===s.length)return s[0];s.length>t.pluralForms.length&&console.error(`For locale=${t.locale}, a maximum of ${t.pluralForms.length} plural forms are expected (${t.pluralForms.join(",")}), but the message contains ${s.length}: ${e}`);const r=t.select(n),i=t.pluralForms.indexOf(r);return s[Math.min(i,s.length-1)]}(t,n,e)}}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);