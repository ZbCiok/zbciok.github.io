"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[6529],{4365:(e,t,a)=>{a.d(t,{W:()=>d});var o=a(6540),n=a(502);const i=["zero","one","two","few","many","other"];function s(e){return i.filter((t=>e.includes(t)))}const r={locale:"en",pluralForms:s(["one","other"]),select:e=>1===e?"one":"other"};function c(){const{i18n:{currentLocale:e}}=(0,n.A)();return(0,o.useMemo)((()=>{try{return function(e){const t=new Intl.PluralRules(e);return{locale:e,pluralForms:s(t.resolvedOptions().pluralCategories),select:e=>t.select(e)}}(e)}catch(t){return console.error(`Failed to use Intl.PluralRules for locale "${e}".\nDocusaurus will fallback to the default (English) implementation.\nError: ${t.message}\n`),r}}),[e])}function d(){const e=c();return{selectMessage:(t,a)=>function(e,t,a){const o=e.split("|");if(1===o.length)return o[0];o.length>a.pluralForms.length&&console.error(`For locale=${a.locale}, a maximum of ${a.pluralForms.length} plural forms are expected (${a.pluralForms.join(",")}), but the message contains ${o.length}: ${e}`);const n=a.select(t),i=a.pluralForms.indexOf(n);return o[Math.min(i,o.length-1)]}(a,t,e)}}},4456:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"apache-hadoop/index","title":"Apache Hadoop","description":"Apache Hadoop","source":"@site/docs/apache-hadoop/index.mdx","sourceDirName":"apache-hadoop","slug":"/apache-hadoop","permalink":"/docs/apache-hadoop","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"slug":"/apache-hadoop"},"sidebar":"tutorialSidebar","previous":{"title":"References","permalink":"/docs/apache-flink/references"},"next":{"title":"Setting up a Single Node Cluster","permalink":"/docs/apache-hadoop/install"}}');var n=a(4848),i=a(8453),s=a(7170),r=a(3304);const c={slug:"/apache-hadoop"},d="Apache Hadoop",l={},h=[{value:"MapReduce",id:"mapreduce",level:2},{value:"HDFS (Hadoop Distributed File System)",id:"hdfs-hadoop-distributed-file-system",level:2},{value:"Read Operation In HDFS",id:"read-operation-in-hdfs",level:3},{value:"Write Operation In HDFS",id:"write-operation-in-hdfs",level:3},{value:"YARN (Yet Another Resource Negotiator)",id:"yarn-yet-another-resource-negotiator",level:2},{value:"Hadoop Common Utilities",id:"hadoop-common-utilities",level:2},{value:"Network Topology In Hadoop",id:"network-topology-in-hadoop",level:2}];function p(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"apache-hadoop",children:"Apache Hadoop"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://hadoop.apache.org/",children:(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Apache Hadoop"})})})," ",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://www.tpointtech.com/hadoop-tutorial",children:"https://www.tpointtech.com/hadoop-tutorial"})})})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsxs)(t.strong,{children:["Apache\u2019s Hadoop is a leading ",(0,n.jsx)(t.a,{href:"/docs/auxiliary-software/big-data",children:(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Big Data"})})})," platform used by IT giants Yahoo, Facebook & Google."]}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Apache Hadoop is an open source software framework used to develop data processing applications which are executed in a distributed computing environment."})," ",(0,n.jsx)(t.em,{children:"(A distributed system is simply any environment where multiple computers or devices are working on a variety of tasks and components, all spread across a network. Components within distributed systems split up the work, coordinating efforts to complete a given job more efficiently than if only a single device ran it.)"})]}),"\n",(0,n.jsxs)(t.p,{children:["Similar to data residing in a local file system of a personal computer system, in Hadoop, data resides in a distributed file system which is called as a ",(0,n.jsx)(t.strong,{children:"Hadoop Distributed File System (HDFS)"}),". The processing model is based on \u2018Data Locality\u2019 concept wherein computational logic is sent to cluster nodes (servers) containing data. This computational logic is nothing, but a compiled version of a program written in a high-level language such as Java. Such a program, processes data stored in Hadoop HDFS."]}),"\n",(0,n.jsx)(t.p,{children:"The Hadoop Architecture Mainly consists of 4 components."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"MapReduce"}),": This is a framework which helps Java programs to do the parallel computation on data using key value pair. The ",(0,n.jsx)(t.strong,{children:"Map"})," task takes input data and converts it into a data set which can be computed in Key value pair. The output of ",(0,n.jsx)(t.strong,{children:"Map"})," task is consumed by ",(0,n.jsx)(t.strong,{children:"Reduce"})," task and then the out of reducer gives the desired result."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"HDFS"})," (Hadoop Distributed File System): It states that the files will be broken into blocks and stored in nodes over the distributed architecture."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"YARN"})," (Yet Another Resource Negotiator): Yet another Resource Negotiator is used for job scheduling and manage the cluster."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Common Utilities or Hadoop Common"}),": These Java libraries are used to start Hadoop and are used by other Hadoop modules."]}),"\n"]}),"\n",(0,n.jsx)("img",{src:"/img/apache-hadoop/hadoop-architecture-and-core-components.png",alt:"hadoop-architecture-and-core-components.png"}),"\n",(0,n.jsx)(t.h2,{id:"mapreduce",children:"MapReduce"}),"\n",(0,n.jsx)("img",{src:"/img/apache-hadoop/map-reduce-diagram.webp",width:"600 px",alt:"map-reduce-diagram.webp"}),"\n",(0,n.jsx)(t.p,{children:"A MapReduce system is usually composed of three steps (even though it's generalized as the combination of Map and Reduce operations/functions). The MapReduce operations are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Map"}),": The input data is first split into smaller blocks. The Hadoop framework then decides how many mappers to use, based on the size of the data to be processed and the memory block available on each mapper server. Each block is then assigned to a mapper for processing. Each \u2018worker\u2019 node applies the map function to the local data, and writes the output to temporary storage. The primary (master) node ensures that only a single copy of the redundant input data is processed."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Shuffle"}),", combine and partition: worker nodes redistribute data based on the output keys (produced by the map function), such that all data belonging to one key is located on the same worker node. As an optional process the combiner (a reducer) can run individually on each mapper server to reduce the data on each mapper even further making reducing the data footprint and shuffling and sorting easier. Partition (not optional) is the process that decides how the data has to be presented to the reducer and also assigns it to a particular reducer."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Reduce"}),": A reducer cannot start while a mapper is still in progress. Worker nodes process each group of ",(0,n.jsx)(t.code,{children:"<key,value>"})," pairs output data, in parallel to produce ",(0,n.jsx)(t.code,{children:"<key,value>"})," pairs as output. All the map output values that have the same key are assigned to a single reducer, which then aggregates the values for that key. Unlike the map function which is mandatory to filter and sort the initial data, the reduce function is optional."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"hdfs-hadoop-distributed-file-system",children:"HDFS (Hadoop Distributed File System)"}),"\n",(0,n.jsxs)(t.p,{children:["More detailed description: ",(0,n.jsx)(t.a,{href:"https://www.simplilearn.com/tutorials/hadoop-tutorial/hdfs",children:(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"HDFS Tutorial"})})})]}),"\n",(0,n.jsx)("img",{src:"/img/apache-hadoop/hdfs-architecture-01.png",width:"600 px",alt:"hdfs-architecture-01.png"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"HDFS has three components:"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"NameNode:"})," There is a single NameNode per cluster. This service stores the file system metadata (e.g., the directory structure), and the file names, and also, the location where the blocks of a file are stored."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"DataNodes:"})," These services usually run on each server that also does the compute. Each DataNode stores blocks from many files. The DataNodes are also responsible for replicating these blocks to other DataNodes to protect files against data loss."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Clients:"})," The client provides access to the file system and the Hadoop/MapReduce jobs that want to access the data. The client, a piece of software embedded in the Hadoop distribution, communicates with the NameNode to find the file and retrieve the block\u2019s locations. Then the client reads or writes the blocks directly from the DataNodes."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"read-operation-in-hdfs",children:"Read Operation In HDFS"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://www.guru99.com/learn-hdfs-a-beginners-guide.html",children:(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Read / Write Operations in HDFS"})})}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(t.p,{children:"Data read request is served by HDFS, NameNode, and DataNode. Let\u2019s call the reader as a \u2018client\u2019. Below diagram depicts file read operation in Hadoop."}),"\n",(0,n.jsx)("img",{src:"/img/apache-hadoop/read-hdfs-01.webp",width:"600 px",alt:"read-hdfs-01.webp"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"A client initiates read request by calling \u2018open()\u2019 method of FileSystem object; it is an object of type DistributedFileSystem."}),"\n",(0,n.jsx)(t.li,{children:"This object connects to namenode using RPC and gets metadata information such as the locations of the blocks of the file. Please note that these addresses are of first few blocks of a file."}),"\n",(0,n.jsx)(t.li,{children:"In response to this metadata request, addresses of the DataNodes having a copy of that block is returned back."}),"\n",(0,n.jsx)(t.li,{children:"Once addresses of DataNodes are received, an object of type FSDataInputStream is returned to the client. FSDataInputStream contains DFSInputStream which takes care of interactions with DataNode and NameNode. In step 4 shown in the above diagram, a client invokes \u2018read()\u2019 method which causes DFSInputStream to establish a connection with the first DataNode with the first block of a file."}),"\n",(0,n.jsx)(t.li,{children:"Data is read in the form of streams wherein client invokes \u2018read()\u2019 method repeatedly. This process of read() operation continues till it reaches the end of block."}),"\n",(0,n.jsx)(t.li,{children:"Once the end of a block is reached, DFSInputStream closes the connection and moves on to locate the next DataNode for the next block"}),"\n",(0,n.jsx)(t.li,{children:"Once a client has done with the reading, it calls a close() method."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"write-operation-in-hdfs",children:"Write Operation In HDFS"}),"\n",(0,n.jsx)("img",{src:"/img/apache-hadoop/write-hdfs-01.webp",width:"600 px",alt:"write-hdfs-01.webp"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"A client initiates write operation by calling \u2018create()\u2019 method of DistributedFileSystem object which creates a new file \u2013 Step no. 1 in the above diagram."}),"\n",(0,n.jsx)(t.li,{children:"DistributedFileSystem object connects to the NameNode using RPC call and initiates new file creation. However, this file creates operation does not associate any blocks with the file. It is the responsibility of NameNode to verify that the file (which is being created) does not exist already and a client has correct permissions to create a new file. If a file already exists or client does not have sufficient permission to create a new file, then IOException is thrown to the client. Otherwise, the operation succeeds and a new record for the file is created by the NameNode."}),"\n",(0,n.jsx)(t.li,{children:"Once a new record in NameNode is created, an object of type FSDataOutputStream is returned to the client. A client uses it to write data into the HDFS. Data write method is invoked (step 3 in the diagram)."}),"\n",(0,n.jsx)(t.li,{children:"FSDataOutputStream contains DFSOutputStream object which looks after communication with DataNodes and NameNode. While the client continues writing data, DFSOutputStream continues creating packets with this data. These packets are enqueued into a queue which is called as DataQueue."}),"\n",(0,n.jsx)(t.li,{children:"There is one more component called DataStreamer which consumes this DataQueue. DataStreamer also asks NameNode for allocation of new blocks thereby picking desirable DataNodes to be used for replication."}),"\n",(0,n.jsx)(t.li,{children:"Now, the process of replication starts by creating a pipeline using DataNodes. In our case, we have chosen a replication level of 3 and hence there are 3 DataNodes in the pipeline."}),"\n",(0,n.jsx)(t.li,{children:"The DataStreamer pours packets into the first DataNode in the pipeline."}),"\n",(0,n.jsx)(t.li,{children:"Every DataNode in a pipeline stores packet received by it and forwards the same to the second DataNode in a pipeline."}),"\n",(0,n.jsx)(t.li,{children:"Another queue, \u2018Ack Queue\u2019 is maintained by DFSOutputStream to store packets which are waiting for acknowledgment from DataNodes."}),"\n",(0,n.jsx)(t.li,{children:"Once acknowledgment for a packet in the queue is received from all DataNodes in the pipeline, it is removed from the \u2018Ack Queue\u2019. In the event of any DataNode failure, packets from this queue are used to reinitiate the operation."}),"\n",(0,n.jsx)(t.li,{children:"After a client is done with the writing data, it calls a close() method (Step 9 in the diagram) Call to close(), results into flushing remaining data packets to the pipeline followed by waiting for acknowledgment."}),"\n",(0,n.jsx)(t.li,{children:"Once a final acknowledgment is received, NameNode is contacted to tell it that the file write operation is complete."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"yarn-yet-another-resource-negotiator",children:"YARN (Yet Another Resource Negotiator)"}),"\n",(0,n.jsx)(t.p,{children:"YARN is a Framework on which MapReduce works. YARN performs 2 operations that are Job scheduling and Resource Management. The Purpose of Job schedular is to divide a big task into small jobs so that each job can be assigned to various slaves in a Hadoop cluster and Processing can be Maximized. Job Scheduler also keeps track of which job is important, which job has more priority, dependencies between the jobs and all the other information like job timing, etc. And the use of Resource Manager is to manage all the resources that are made available for running a Hadoop cluster."}),"\n",(0,n.jsx)(t.p,{children:"Features of YARN"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Multi-Tenancy"}),"\n",(0,n.jsx)(t.li,{children:"Scalability"}),"\n",(0,n.jsx)(t.li,{children:"Cluster-Utilization"}),"\n",(0,n.jsx)(t.li,{children:"Compatibility"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"hadoop-common-utilities",children:"Hadoop Common Utilities"}),"\n",(0,n.jsx)(t.p,{children:"Hadoop common or Common utilities are nothing but our java library and java files or we can say the java scripts that we need for all the other components present in a Hadoop cluster. these utilities are used by HDFS, YARN, and MapReduce for running the cluster. Hadoop Common verify that Hardware failure in a Hadoop cluster is common so it needs to be solved automatically in software by Hadoop Framework."}),"\n",(0,n.jsx)(t.h2,{id:"network-topology-in-hadoop",children:"Network Topology In Hadoop"}),"\n",(0,n.jsx)(t.p,{children:"Topology (Arrangement) of the network, affects the performance of the Hadoop cluster when the size of the Hadoop cluster grows. In addition to the performance, one also needs to care about the high availability and handling of failures. In order to achieve this Hadoop, cluster formation makes use of network topology."}),"\n",(0,n.jsx)("img",{src:"/img/apache-hadoop/hadoop-data-center-01.jpg",width:"600 px",alt:"hadoop-data-center-01.jpg"}),"\n",(0,n.jsx)(t.p,{children:"Typically, network bandwidth is an important factor to consider while forming any network. However, as measuring bandwidth could be difficult, in Hadoop, a network is represented as a tree and distance between nodes of this tree (number of hops) is considered as an important factor in the formation of Hadoop cluster. Here, the distance between two nodes is equal to sum of their distance to their closest common ancestor."}),"\n",(0,n.jsx)(t.p,{children:"Hadoop cluster consists of a data center, the rack and the node which actually executes jobs. Here, data center consists of racks and rack consists of nodes. Network bandwidth available to processes varies depending upon the location of the processes. That is, the bandwidth available becomes lesser as we go away from-"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Processes on the same node"}),"\n",(0,n.jsx)(t.li,{children:"Different nodes on the same rack"}),"\n",(0,n.jsx)(t.li,{children:"Nodes on different racks of the same data center"}),"\n",(0,n.jsx)(t.li,{children:"Nodes in different data centers"}),"\n"]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsx)("br",{}),"\n","\n",(0,n.jsx)(s.A,{items:(0,r.$S)().items})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},7170:(e,t,a)=>{a.d(t,{A:()=>j});a(6540);var o=a(4164),n=a(7936),i=a(7634),s=a(4365),r=a(5242),c=a(9979),d=a(4861);const l={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var h=a(4848);function p(e){let{href:t,children:a}=e;return(0,h.jsx)(i.A,{href:t,className:(0,o.A)("card padding--lg",l.cardContainer),children:a})}function u(e){let{href:t,icon:a,title:n,description:i}=e;return(0,h.jsxs)(p,{href:t,children:[(0,h.jsxs)(d.A,{as:"h2",className:(0,o.A)("text--truncate",l.cardTitle),title:n,children:[a," ",n]}),i&&(0,h.jsx)("p",{className:(0,o.A)("text--truncate",l.cardDescription),title:i,children:i})]})}function m(e){let{item:t}=e;const a=(0,n.Nr)(t),o=function(){const{selectMessage:e}=(0,s.W)();return t=>e(t,(0,c.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:t}))}();return a?(0,h.jsx)(u,{href:a,icon:"\ud83d\uddc3\ufe0f",title:t.label,description:t.description??o(t.items.length)}):null}function f(e){let{item:t}=e;const a=(0,r.A)(t.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",o=(0,n.cC)(t.docId??void 0);return(0,h.jsx)(u,{href:t.href,icon:a,title:t.label,description:t.description??o?.description})}function g(e){let{item:t}=e;switch(t.type){case"link":return(0,h.jsx)(f,{item:t});case"category":return(0,h.jsx)(m,{item:t});default:throw new Error(`unknown item type ${JSON.stringify(t)}`)}}function x(e){let{className:t}=e;const a=(0,n.$S)();return(0,h.jsx)(j,{items:a.items,className:t})}function j(e){const{items:t,className:a}=e;if(!t)return(0,h.jsx)(x,{...e});const i=(0,n.d1)(t);return(0,h.jsx)("section",{className:(0,o.A)("row",a),children:i.map(((e,t)=>(0,h.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,h.jsx)(g,{item:e})},t)))})}},8453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>r});var o=a(6540);const n={},i=o.createContext(n);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);