"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[7500],{2253:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var r=n(4848),a=n(8453),s=n(3514),i=n(5068);const o={slug:"/apache-flink/operators"},l="Operators",c={id:"streams/apache-flink/Operators/index",title:"Operators",description:"Operators",source:"@site/docs/streams/apache-flink/Operators/index.mdx",sourceDirName:"streams/apache-flink/Operators",slug:"/apache-flink/operators",permalink:"/docs/apache-flink/operators",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{slug:"/apache-flink/operators"},sidebar:"tutorialSidebar",previous:{title:"Apache Flink",permalink:"/docs/apache-flink"},next:{title:"Windowing",permalink:"/docs/streams/apache-flink/Operators/windowing"}},d={},h=[{value:"DataStream Transformations",id:"datastream-transformations",level:2},{value:"Physical Partitioning",id:"physical-partitioning",level:2},{value:"Task Chaining and Resource Groups",id:"task-chaining-and-resource-groups",level:2},{value:"Name And Description",id:"name-and-description",level:2}];function m(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"operators",children:"Operators"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://nightlies.apache.org/flink/flink-docs-release-1.20/docs/dev/datastream/operators/overview/",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Operators"})})}),(0,r.jsx)("br",{}),"\nOperators transform one or more DataStreams into a new DataStream."]}),"\n",(0,r.jsx)(t.h2,{id:"datastream-transformations",children:"DataStream Transformations"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Map"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nTakes one element and produces one element."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"FlatMap"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nTakes one element and produces zero, one, or more elements."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Filter"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nEvaluates a boolean function for each element and retains those for which the function returns true."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"KeyBy"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 KeyedStream",(0,r.jsx)("br",{}),"\nLogically partitions a stream into disjoint partitions. All records with the same key are assigned to the same partition. Internally, keyBy() is implemented with hash partitioning."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Reduce"}),(0,r.jsx)("br",{}),"\nKeyedStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nA \u201crolling\u201d reduce on a keyed data stream. Combines the current element with the last reduced value and emits the new value."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Window"}),(0,r.jsx)("br",{}),"\nKeyedStream \u2192 WindowedStream",(0,r.jsx)("br",{}),"\nWindows can be defined on already partitioned KeyedStreams. Windows group the data in each key according to some characteristic (e.g., the data that arrived within the last 5 seconds)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"WindowAll"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 AllWindowedStream",(0,r.jsx)("br",{}),"\nWindows can be defined on regular DataStreams. Windows group all the stream events according to some characteristic (e.g., the data that arrived within the last 5 seconds)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Window Apply"}),(0,r.jsx)("br",{}),"\nWindowedStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nAllWindowedStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nApplies a general function to the window as a whole. Below is a function that manually sums the elements of a window."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"WindowReduce"}),(0,r.jsx)("br",{}),"\nWindowedStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nApplies a functional reduce function to the window and returns the reduced value."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Union"}),(0,r.jsx)("br",{}),"\nDataStream* \u2192 DataStream",(0,r.jsx)("br",{}),"\nUnion of two or more data streams creating a new stream containing all the elements from all the streams. Note: If you union a data stream with itself you will get each element twice in the resulting stream."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Window Join"}),(0,r.jsx)("br",{}),"\nDataStream,DataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nJoin two data streams on a given key and a common window."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Interval Join"}),(0,r.jsx)("br",{}),"\nKeyedStream,KeyedStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nJoin two elements e1 and e2 of two keyed streams with a common key over a given time interval."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Window CoGroup"}),(0,r.jsx)("br",{}),"\nDataStream,DataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nCogroups two data streams on a given key and a common window."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Connect"}),(0,r.jsx)("br",{}),"\nDataStream,DataStream \u2192 ConnectedStream",(0,r.jsx)("br",{}),"\n\u201cConnects\u201d two data streams retaining their types. Connect allowing for shared state between the two streams."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"CoMap, CoFlatMap"}),(0,r.jsx)("br",{}),"\nConnectedStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nSimilar to map and flatMap on a connected data stream."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Cache"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 CachedDataStream",(0,r.jsx)("br",{}),"\nCache the intermediate result of the transformation. Currently, only jobs that run with batch execution mode are supported. The cache intermediate result is generated lazily at the first time the intermediate result is computed so that the result can be reused by later jobs. If the cache is lost, it will be recomputed using the original transformations."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Full Window Partition"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 PartitionWindowedStream",(0,r.jsx)("br",{}),"\nCollects all records of each partition separately into a full window and processes them. The window emission will be triggered at the end of inputs. This approach is primarily applicable to batch processing scenarios. For non-keyed DataStream, a partition contains all records of a subtask. For KeyedStream, a partition contains all records of a key."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"physical-partitioning",children:"Physical Partitioning"}),"\n",(0,r.jsx)(t.p,{children:"Flink also gives low-level control (if desired) on the exact stream partitioning after a transformation, via the following functions."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Custom Partitioning"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nUses a user-defined Partitioner to select the target task for each element."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Random Partitioning"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nPartitions elements randomly according to a uniform distribution."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Rescaling"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nPartitions elements, round-robin, to a subset of downstream operations."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Broadcasting"}),(0,r.jsx)("br",{}),"\nDataStream \u2192 DataStream",(0,r.jsx)("br",{}),"\nBroadcasts elements to every partition."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"task-chaining-and-resource-groups",children:"Task Chaining and Resource Groups"}),"\n",(0,r.jsx)(t.p,{children:"Chaining two subsequent transformations means co-locating them within the same thread for better performance. Flink by default chains operators if this is possible (e.g., two subsequent map transformations)."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Start New Chain"}),(0,r.jsx)("br",{}),"\nBegin a new chain, starting with this operator. The two mappers will be chained, and filter will not be chained to the first mapper."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Disable Chaining"}),(0,r.jsx)("br",{}),"\nDo not chain the map operator."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Set Slot Sharing Group"}),(0,r.jsx)("br",{}),"\nSet the slot sharing group of an operation. Flink will put operations with the same slot sharing group into the same slot while keeping operations that don\u2019t have the slot sharing group in other slots. This can be used to isolate slots. The slot sharing group is inherited from input operations if all input operations are in the same slot sharing group. The name of the default slot sharing group is \u201cdefault\u201d, operations can explicitly be put into this group by calling slotSharingGroup(\u201cdefault\u201d)."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"name-and-description",children:"Name And Description"}),"\n",(0,r.jsx)(t.p,{children:"Operators and job vertices in flink have a name and a description. Both name and description are introduction about what an operator or a job vertex is doing, but they are used differently."}),"\n",(0,r.jsx)(t.p,{children:"The name of operator and job vertex will be used in web ui, thread name, logging, metrics, etc. The name of a job vertex is constructed based on the name of operators in it. The name needs to be as concise as possible to avoid high pressure on external systems."}),"\n",(0,r.jsx)(t.p,{children:"The description will be used in the execution plan and displayed as the details of a job vertex in web UI. The description of a job vertex is constructed based on the description of operators in it. The description can contain detail information about operators to facilitate debugging at runtime."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)("br",{}),"\n","\n",(0,r.jsx)(s.A,{items:(0,i.$S)().items})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},3514:(e,t,n)=>{n.d(t,{A:()=>f});n(6540);var r=n(4164),a=n(6972),s=n(8774),i=n(5846),o=n(6654),l=n(1312),c=n(1107);const d={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var h=n(4848);function m(e){let{href:t,children:n}=e;return(0,h.jsx)(s.A,{href:t,className:(0,r.A)("card padding--lg",d.cardContainer),children:n})}function u(e){let{href:t,icon:n,title:a,description:s}=e;return(0,h.jsxs)(m,{href:t,children:[(0,h.jsxs)(c.A,{as:"h2",className:(0,r.A)("text--truncate",d.cardTitle),title:a,children:[n," ",a]}),s&&(0,h.jsx)("p",{className:(0,r.A)("text--truncate",d.cardDescription),title:s,children:s})]})}function p(e){let{item:t}=e;const n=(0,a.Nr)(t),r=function(){const{selectMessage:e}=(0,i.W)();return t=>e(t,(0,l.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:t}))}();return n?(0,h.jsx)(u,{href:n,icon:"\ud83d\uddc3\ufe0f",title:t.label,description:t.description??r(t.items.length)}):null}function x(e){let{item:t}=e;const n=(0,o.A)(t.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",r=(0,a.cC)(t.docId??void 0);return(0,h.jsx)(u,{href:t.href,icon:n,title:t.label,description:t.description??r?.description})}function j(e){let{item:t}=e;switch(t.type){case"link":return(0,h.jsx)(x,{item:t});case"category":return(0,h.jsx)(p,{item:t});default:throw new Error(`unknown item type ${JSON.stringify(t)}`)}}function g(e){let{className:t}=e;const n=(0,a.$S)();return(0,h.jsx)(f,{items:n.items,className:t})}function f(e){const{items:t,className:n}=e;if(!t)return(0,h.jsx)(g,{...e});const s=(0,a.d1)(t);return(0,h.jsx)("section",{className:(0,r.A)("row",n),children:s.map(((e,t)=>(0,h.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,h.jsx)(j,{item:e})},t)))})}},5846:(e,t,n)=>{n.d(t,{W:()=>c});var r=n(6540),a=n(4586);const s=["zero","one","two","few","many","other"];function i(e){return s.filter((t=>e.includes(t)))}const o={locale:"en",pluralForms:i(["one","other"]),select:e=>1===e?"one":"other"};function l(){const{i18n:{currentLocale:e}}=(0,a.A)();return(0,r.useMemo)((()=>{try{return function(e){const t=new Intl.PluralRules(e);return{locale:e,pluralForms:i(t.resolvedOptions().pluralCategories),select:e=>t.select(e)}}(e)}catch(t){return console.error(`Failed to use Intl.PluralRules for locale "${e}".\nDocusaurus will fallback to the default (English) implementation.\nError: ${t.message}\n`),o}}),[e])}function c(){const e=l();return{selectMessage:(t,n)=>function(e,t,n){const r=e.split("|");if(1===r.length)return r[0];r.length>n.pluralForms.length&&console.error(`For locale=${n.locale}, a maximum of ${n.pluralForms.length} plural forms are expected (${n.pluralForms.join(",")}), but the message contains ${r.length}: ${e}`);const a=n.select(t),s=n.pluralForms.indexOf(a);return r[Math.min(s,r.length-1)]}(n,t,e)}}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(6540);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);