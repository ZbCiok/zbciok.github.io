"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[3014],{4080:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"artificial-intelligence/machine-learning/examples/fraud-detection/credit-card-fraud-detection-01","title":"Bank Transaction Fraud Detection  01","description":"Problem Statement","source":"@site/docs/artificial-intelligence/machine-learning/examples/fraud-detection/credit-card-fraud-detection-01.mdx","sourceDirName":"artificial-intelligence/machine-learning/examples/fraud-detection","slug":"/artificial-intelligence/machine-learning/examples/fraud-detection/credit-card-fraud-detection-01","permalink":"/docs/artificial-intelligence/machine-learning/examples/fraud-detection/credit-card-fraud-detection-01","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":110,"frontMatter":{"sidebar_position":110},"sidebar":"tutorialSidebar","previous":{"title":"Fraud Detection","permalink":"/docs/artificial-intelligence/machine-learning/examples/fraud-detection/"},"next":{"title":"Health","permalink":"/docs/artificial-intelligence/machine-learning/examples/health/"}}');var i=t(4848),r=t(8453);const s={sidebar_position:110},o="Bank Transaction Fraud Detection  01",l={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Objectives for Bank Transaction Fraud Detection",id:"objectives-for-bank-transaction-fraud-detection",level:2},{value:"Technologies Used",id:"technologies-used",level:2},{value:"Jupyter Notebook",id:"jupyter-notebook",level:2},{value:"Stage 1 - Importing Libraries",id:"stage-1---importing-libraries",level:2},{value:"Output",id:"output",level:4},{value:"Output",id:"output-1",level:4},{value:"Output",id:"output-2",level:4},{value:"Output",id:"output-3",level:4},{value:"Stage 2 - Data Preprocessing",id:"stage-2---data-preprocessing",level:2},{value:"Output",id:"output-4",level:4},{value:"Output",id:"output-5",level:4},{value:"Output",id:"output-6",level:4},{value:"Output",id:"output-7",level:4},{value:"Output",id:"output-8",level:4},{value:"Output",id:"output-9",level:4},{value:"Output",id:"output-10",level:4},{value:"Stage 3 - Exploratory Data Analysis (EDA)",id:"stage-3---exploratory-data-analysis-eda",level:2},{value:"EDA for Numerical Columns",id:"eda-for-numerical-columns",level:3},{value:"Output",id:"output-11",level:4},{value:"Output",id:"output-12",level:4},{value:"Output",id:"output-13",level:4},{value:"EDA for Categorical Columns",id:"eda-for-categorical-columns",level:3},{value:"Output",id:"output-14",level:4},{value:"Output",id:"output-15",level:4},{value:"Output",id:"output-16",level:4},{value:"Stage 4 - Convert Date Time Columns to Numerical Columns",id:"stage-4---convert-date-time-columns-to-numerical-columns",level:2},{value:"Output",id:"output-17",level:4},{value:"Output",id:"output-18",level:4},{value:"Output",id:"output-19",level:4},{value:"Stage 5 - Encode Categorical Features",id:"stage-5---encode-categorical-features",level:2},{value:"Output",id:"output-20",level:4},{value:"Output",id:"output-21",level:4},{value:"Output",id:"output-22",level:4},{value:"Stage 6 - EDA after Label Encoder",id:"stage-6---eda-after-label-encoder",level:2},{value:"Output",id:"output-23",level:4},{value:"Stage 7 - Visualize Fraud Patterns and Distribution of Features",id:"stage-7---visualize-fraud-patterns-and-distribution-of-features",level:2},{value:"Output",id:"output-24",level:4},{value:"Output",id:"output-25",level:4},{value:"Stage 8 - Plot Correlation Matrix to Understand Feature Relationships",id:"stage-8---plot-correlation-matrix-to-understand-feature-relationships",level:2},{value:"Output",id:"output-26",level:4},{value:"Output",id:"output-27",level:4},{value:"Stage 9 - Feature Importance using Random Forest",id:"stage-9---feature-importance-using-random-forest",level:2},{value:"Output",id:"output-28",level:4},{value:"Output",id:"output-29",level:4},{value:"Stage 10 - Select Only Important Features",id:"stage-10---select-only-important-features",level:2},{value:"Output",id:"output-30",level:4},{value:"Stage 11 - Perform PCA (Principal Component Analysis)",id:"stage-11---perform-pca-principal-component-analysis",level:2},{value:"Output",id:"output-31",level:4},{value:"Stage 12 - Train-test Split",id:"stage-12---train-test-split",level:2},{value:"Stage 13 - Feature Scaling",id:"stage-13---feature-scaling",level:2},{value:"Stage 14 - Model Training and Evaluation",id:"stage-14---model-training-and-evaluation",level:2},{value:"Output",id:"output-32",level:4},{value:"Stage 15 - Displaying Evaluation Results for All Models",id:"stage-15---displaying-evaluation-results-for-all-models",level:2},{value:"Stage 16 - Plotting the Train Vs Test Accuracy Chart",id:"stage-16---plotting-the-train-vs-test-accuracy-chart",level:2},{value:"Output",id:"output-33",level:4},{value:"Stage 17 - Final Conclusion",id:"stage-17---final-conclusion",level:2},{value:"Conclusion:",id:"conclusion",level:3},{value:"Final Remarks:",id:"final-remarks",level:3}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"bank-transaction-fraud-detection--01",children:"Bank Transaction Fraud Detection  01"})}),"\n",(0,i.jsx)(e.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/pictures/fraud-prevention-pics-01.png",alt:"fraud-prevention-pics-01.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.p,{children:"With the rapid growth of digital banking, fraudulent transactions have become a significant concern for financial institutions. The challenge is to build a robust system to detect and prevent fraudulent transactions in real-time while maintaining customer convenience and privacy."}),"\n",(0,i.jsx)(e.p,{children:'The dataset provided contains detailed information about bank transactions, including customer demographics, transaction metadata, merchant categories, device types, transaction locations, and other relevant attributes. Key fields like transaction descriptions, device usage, and merchant categories provide vital insights for identifying anomalous activities. The "Is_Fraud" label offers a foundation for supervised learning techniques to differentiate between genuine and fraudulent transactions.'}),"\n",(0,i.jsx)(e.p,{children:"The objective of this problem is to analyze transaction patterns and develop predictive models that can accurately classify transactions as fraudulent or legitimate. This task involves exploring feature correlations, detecting unusual transaction behavior, and leveraging machine learning algorithms to create a scalable and efficient fraud detection system."}),"\n",(0,i.jsx)(e.p,{children:"A successful solution will not only detect fraudulent activities but also minimize false positives, ensuring genuine transactions are not unnecessarily flagged. Insights derived from this analysis can help strengthen security measures, optimize fraud prevention strategies, and enhance the overall banking experience for customers."}),"\n",(0,i.jsx)(e.h2,{id:"objectives-for-bank-transaction-fraud-detection",children:"Objectives for Bank Transaction Fraud Detection"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Fraud Detection:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Develop a predictive model to classify bank transactions as fraudulent or legitimate using historical transaction data."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Anomaly Detection:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Identify unusual patterns or behaviors in customer transactions that may indicate potential fraud."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Feature Analysis:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Explore key features such as merchant categories, transaction devices, transaction locations, and account types to understand their impact on fraud detection."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Model Performance Optimization:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Ensure the fraud detection system achieves high accuracy, precision, and recall while minimizing false positives and false negatives."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Real-Time Fraud Prevention:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Create a scalable solution that can potentially be adapted for real-time fraud detection in production environments."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Customer Behavior Insights:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Analyze legitimate transaction behaviors to gain insights into customer banking patterns and preferences."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Device and Location Security:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand the correlation between transaction device types, locations, and fraudulent activities."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Security Enhancements:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Provide actionable recommendations to the bank for improving fraud prevention strategies and enhancing digital transaction security."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"technologies-used",children:"Technologies Used"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Python"}),"\n",(0,i.jsx)(e.li,{children:"Scikit-learn"}),"\n",(0,i.jsx)(e.li,{children:"Pandas"}),"\n",(0,i.jsx)(e.li,{children:"NumPy"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"jupyter-notebook",children:"Jupyter Notebook"}),"\n",(0,i.jsx)(e.h2,{id:"stage-1---importing-libraries",children:"Stage 1 - Importing Libraries"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# Import necessary libraries\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom imblearn.over_sampling import SMOTE\nfrom sklearn.decomposition import PCA\nfrom sklearn.utils.class_weight import compute_class_weight\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder\nfrom sklearn.metrics import classification_report, confusion_matrix, roc_auc_score\nfrom sklearn.linear_model import LogisticRegression\n# from sklearn.linear_model import LinearDiscriminantAnalysis as LDA, RidgeClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, AdaBoostClassifier, BaggingClassifier\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.metrics import accuracy_score, classification_report, confusion_matrix\nfrom sklearn import metrics\nimport xgboost as xgb\nimport lightgbm as lgb\nimport catboost as cb\nimport warnings\n\n# Suppress all warnings\nwarnings.filterwarnings("ignore")\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Load the dataset\ndf = pd.read_csv('Bank_Transaction_Fraud_Detection.csv')\ndf.head()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\n \tCustomer_ID \t                        Customer_Name \t      Gender \tAge \tState \t        City \t             Bank_Branch                   Account_Type     Transaction_ID \t                        Transaction_Date \t... \tMerchant_Category   Account_Balance \tTransaction_Device    Transaction_Location             Device_Type   Is_Fraud \tTransaction_Currency \tCustomer_Contact    Transaction_Description    Customer_Email\n0 \td5f6ec07-d69e-4f47-b9b4-7c58ff17c19e \tOsha Tella            Male      60      Kerala \t        Thiruvananthapuram   Thiruvananthapuram Branch     Savings          4fa3208f-9e23-42dc-b330-844829d0c12c \t23-01-2025 \t        ... \tRestaurant          74557.27 \t        Voice Assistant       Thiruvananthapuram, Kerala       POS           0 \t        INR \t                +9198579XXXXXX \t    Bitcoin transaction        oshaXXXXX@XXXXX.com\n1 \t7c14ad51-781a-4db9-b7bd-67439c175262 \tHredhaan Khosla       Female    51      Maharashtra \tNashik               Nashik Branch                 Business         c9de0c06-2c4c-40a9-97ed-3c7b8f97c79c \t11-01-2025 \t        ... \tRestaurant          74622.66 \t        POS Mobile Device     Nashik, Maharashtra              Desktop       0 \t        INR \t                +9191074XXXXXX \t    Grocery delivery           hredhaanXXXX@XXXXXX.com\n2 \t3a73a0e5-d4da-45aa-85f3-528413900a35 \tEkani Nazareth \t      Male      20      Bihar \t        Bhagalpur            Bhagalpur Branch              Savings          e41c55f9-c016-4ff3-872b-cae72467c75c \t25-01-2025 \t        ... \tGroceries           66817.99 \t        ATM                   Bhagalpur, Bihar                 Desktop       0 \t        INR \t                +9197745XXXXXX \t    Mutual fund investment     ekaniXXX@XXXXXX.com\n3 \t7902f4ef-9050-4a79-857d-9c2ea3181940 \tYamini Ramachandran   Female    57      Tamil Nadu      Chennai              Chennai Branch                Business         7f7ee11b-ff2c-45a3-802a-49bc47c02ecb \t19-01-2025 \t        ... \tEntertainment       58177.08 \t        POS Mobile App        Chennai, Tamil Nadu              Mobile        0 \t        INR \t                +9195889XXXXXX \t    Food delivery              yaminiXXXXX@XXXXXXX.com\n4 \t3a4bba70-d9a9-4c5f-8b92-1735fd8c19e9 \tKritika Rege \t      Female    43      Punjab \t        Amritsar             Amritsar Branch               Savings          f8e6ac6f-81a1-4985-bf12-f60967d852ef \t30-01-2025 \t        ... \tEntertainment       16108.56 \t        Virtual Card          Amritsar, Punjab                 Mobile        0 \t        INR \t                +9195316XXXXXX \t    Debt repayment             kritikaXXXX@XXXXXX.com\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.info()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-1",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/pictures/fraud-prevention-pics-01.png",alt:"fraud-prevention-pics-01.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.shape\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-2",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"(200000, 24)\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.duplicated().sum()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-3",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"0\n"})}),"\n",(0,i.jsx)(e.h2,{id:"stage-2---data-preprocessing",children:"Stage 2 - Data Preprocessing"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# Checking for missing values\nprint("Missing NULL values in the dataset:")\nprint(df.isnull().sum())\nprint("-"*80)\nprint("Missing N/A values in the dataset:")\nprint(df.isna().sum())\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-4",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/02-df.isnull().sum().png",alt:"02-df.isnull().sum().png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/03-df.isna().sum().png",alt:"03-df.isna().sum().png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"desc = pd.DataFrame(index = list(df))\ndesc['type'] = df.dtypes\ndesc['count'] = df.count()\ndesc['nunique'] = df.nunique()\ndesc['%unique'] = desc['nunique'] /len(df) * 100\ndesc['null'] = df.isnull().sum()\ndesc['%null'] = desc['null'] / len(df) * 100\ndesc = pd.concat([desc,df.describe().T.drop('count',axis=1)],axis=1)\ndesc.sort_values(by=['type','null']).style.background_gradient(cmap='YlOrBr')\\\n    .bar(subset=['mean'],color='green')\\\n    .bar(subset=['max'],color='red')\\\n    .bar(subset=['min'], color='pink')\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-5",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/04-pd-DataFrame.png",alt:"04-pd-DataFrame.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# Get a list of categorical columns in the dataframe\ncategorical_columns = df.select_dtypes(include=[\'object\']).columns\n\n# Check the unique values and their counts for each categorical column\nfor col in categorical_columns:\n    print(f"Column: {col}")\n    print("-" * 25)\n    print(f"Unique values: {df[col].nunique()}")\n    print(f"Unique values sample: {df[col].unique()[:10]}")  # Display a sample of unique values\n    print("-" * 50)\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-6",children:"Output"}),"\n",(0,i.jsx)(e.p,{children:"Check the unique values and their counts for each categorical column"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/05-customer_id.png",alt:"05-customer_id.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/06-customer-name.png",alt:"06-customer-name.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/07-column-gender.png",alt:"07-column-gender.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/08-column-state.png",alt:"08-column-state.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/09-column-city.png",alt:"09-column-city.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/10-column-bank-branch.png",alt:"10-column-bank-branch.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/11-column-account-type.png",alt:"11-column-account-type.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/12-column-transaction-id.png",alt:"12-column-transaction-id.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/13-column-transaction-date.png",alt:"13-column-transaction-date.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/14-column-transaction-time.png",alt:"14-column-transaction-time.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/15-column-merchant-id.png",alt:"15-column-merchant-id.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/16-column-transaction-type.png",alt:"16-column-transaction-type.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/17-column-merchant-category.png",alt:"17-column-merchant-category.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/18-column-transaction-device.png",alt:"18-column-transaction-device.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/19-column-transaction-location.png",alt:"19-column-transaction-location.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/20-column-device-type.png",alt:"20-column-device-type.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/21-column-transaction-currency.png",alt:"21-column-transaction-currency.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/22-column-customer-contact.png",alt:"22-column-customer-contact.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/23-column-transaction-description.png",alt:"23-column-transaction-description.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/24-column-customer-email.png",alt:"24-column-customer-email.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# If a column has only one unique value, it won\'t be useful for prediction.\nsingle_value_columns = [col for col in df.columns if df[col].nunique() == 1]\nprint("Columns with only one unique value:", single_value_columns)\n\n# Dropping columns with one unique value\ndf = df.drop(columns=single_value_columns)\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-7",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Columns with only one unique value: ['Transaction_Currency']\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Checking columns after dropping one unique columns\ndf.columns\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-8",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Index(['Customer_ID', 'Customer_Name', 'Gender', 'Age', 'State', 'City',\n       'Bank_Branch', 'Account_Type', 'Transaction_ID', 'Transaction_Date',\n       'Transaction_Time', 'Transaction_Amount', 'Merchant_ID',\n       'Transaction_Type', 'Merchant_Category', 'Account_Balance',\n       'Transaction_Device', 'Transaction_Location', 'Device_Type', 'Is_Fraud',\n       'Customer_Contact', 'Transaction_Description', 'Customer_Email'],\n      dtype='object')\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Drop the columns which are not useful for the model evaluation\ndf = df.drop(columns=['Customer_Contact', 'Customer_Email', 'Customer_Name', 'Customer_ID', 'Transaction_ID', 'Merchant_ID'])\nprint(df.shape)\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-9",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"(200000, 17)\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Checking columns after dropping not useful columns\ndf.columns\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-10",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Index(['Gender', 'Age', 'State', 'City', 'Bank_Branch', 'Account_Type',\n       'Transaction_Date', 'Transaction_Time', 'Transaction_Amount',\n       'Transaction_Type', 'Merchant_Category', 'Account_Balance',\n       'Transaction_Device', 'Transaction_Location', 'Device_Type', 'Is_Fraud',\n       'Transaction_Description'],\n      dtype='object')\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"stage-3---exploratory-data-analysis-eda",children:"Stage 3 - Exploratory Data Analysis (EDA)"}),"\n",(0,i.jsx)(e.h3,{id:"eda-for-numerical-columns",children:"EDA for Numerical Columns"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# For numerical columns, we'll fill missing values with the median of each column\nnumerical_columns = df.select_dtypes(include=['float64', 'int64']).columns\nfor col in numerical_columns:\n    df[col] = df[col].fillna(df[col].median())\n\nprint(numerical_columns)\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-11",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Index(['Age', 'Transaction_Amount', 'Account_Balance', 'Is_Fraud'], dtype='object')\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Create a figure with 2 subplots in a horizontal row\nfig, axes = plt.subplots(1, 2, figsize=(15, 6))  # 1 row, 2 columns\n\n# KDE plot for the 'Is_Fraud' column (on the first subplot)\nsns.kdeplot(df[\"Is_Fraud\"], fill=True, ax=axes[0])\naxes[0].set_title('Target Variable Distribution')\n\n# Count plot for the 'Is_Fraud' column (on the second subplot)\nsns.countplot(x='Is_Fraud', data=df, ax=axes[1])\naxes[1].set_title('Fraudulent Transactions Count')\n\n# Adjust layout to prevent overlap\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-12",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/25-kde-count-plots.png",alt:"25-kde-count-plots.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Loop through each numerical column in your DataFrame\nfor col in numerical_columns:\n    plt.style.use(\"fivethirtyeight\")\n    plt.figure(figsize=(10, 6))\n\n    # Create the boxplot\n    sns.boxplot(x=df[col])\n    plt.title(f'Distribution of {col}')\n    plt.xlabel(col)\n\n    # Show the plot\n    plt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-13",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/26-distribution-age.png",alt:"26-distribution-age.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/27-distribution-transaction-amount.png",alt:"27-distribution-transaction-amount.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/28-distribtution-account-balance.png",alt:"28-distribtution-account-balance.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/29-distribution-is-fraud.png",alt:"29-distribution-is-fraud.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"eda-for-categorical-columns",children:"EDA for Categorical Columns"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Index(['Customer_ID', 'Customer_Name', 'Gender', 'State', 'City',\n       'Bank_Branch', 'Account_Type', 'Transaction_ID', 'Transaction_Date',\n       'Transaction_Time', 'Merchant_ID', 'Transaction_Type',\n       'Merchant_Category', 'Transaction_Device', 'Transaction_Location',\n       'Device_Type', 'Transaction_Currency', 'Customer_Contact',\n       'Transaction_Description', 'Customer_Email'],\n      dtype='object')\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-14",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/30-histogram-age-gende-distr.png",alt:"30-histogram-age-gende-distr.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Calculate the number of rows needed based on the number of charts\nnum_cols = 3  # Number of charts per row\n# num_rows = (len(categorical_columns) + num_cols - 1) // num_cols  # Calculate rows required for all charts\nnum_rows = 2 # Number of rows\nfig, axes = plt.subplots(num_rows, num_cols, figsize=(15, num_rows * 6))  # Adjust figure size for more rows\n\n# Flatten the axes array for easier iteration\naxes = axes.flatten()\n\nax_index = 0\nfor col in categorical_columns:\n    unique_values = df[col].nunique()\n    if unique_values < 10:  # Only plot if unique values are less than 10\n        # Plot on the respective subplot\n        ax = axes[ax_index]\n        ax.pie(df[col].value_counts(), labels=df[col].unique(), autopct='%1.1f%%')\n        ax.set_title(f'{col} Distribution')\n\n        # Move to the next subplot\n        ax_index += 1\n\n# Hide any unused subplots (in case there are fewer than `num_rows * num_cols` charts)\nfor i in range(ax_index, len(axes)):\n    axes[i].axis('off')\n\n# Adjust layout\nplt.tight_layout()\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-15",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/31-number-charts-per-row.png",alt:"31-number-charts-per-row.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Filter categorical columns with less than 20 unique values\ncategorical_cols = df.select_dtypes(include=['object']).columns\ncategorical_cols = [col for col in categorical_cols if df[col].nunique() < 20]\n\n# Set the number of charts per row and rows\nnum_cols = 3  # Number of charts per row\nnum_rows = 2  # Number of rows\n\n# Calculate the total number of subplots needed\ntotal_plots = len(categorical_cols)\n\n# Create a figure with the appropriate number of rows and columns\nplt.figure(figsize=(15, 5 * num_rows))\n\n# Plot the count plots for the filtered categorical columns\nfor i, col in enumerate(categorical_cols):\n    plt.subplot(num_rows, num_cols, i + 1)\n    sns.countplot(data=df, x=col, hue='Is_Fraud')\n    plt.title(f'Fraud by {col}')\n    plt.xticks(rotation=45)\n\nplt.tight_layout()\nplt.show()\n\n# Calculate churn rate by categories\nprint(\"\\Fraud Rate by Categories:\")\nfor col in categorical_cols:\n    print(f\"\\n{col} Analysis:\")\n    print(df.groupby(col)['Is_Fraud'].mean().round(3) * 100)\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-16",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/32-filter-categorical-colums.png",alt:"32-filter-categorical-colums.png"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\\Fraud Rate by Categories:\n\nGender Analysis:\nGender\nFemale    5.0\nMale      5.1\nName: Is_Fraud, dtype: float64\n\nAccount_Type Analysis:\nAccount_Type\nBusiness    5.2\nChecking    4.9\nSavings     5.0\nName: Is_Fraud, dtype: float64\n\nTransaction_Type Analysis:\nTransaction_Type\nBill Payment    4.9\nCredit          5.1\nDebit           5.1\nTransfer        5.2\nWithdrawal      4.9\nName: Is_Fraud, dtype: float64\n\nMerchant_Category Analysis:\nMerchant_Category\nClothing         5.2\nElectronics      5.0\nEntertainment    4.8\nGroceries        5.2\nHealth           5.0\nRestaurant       5.0\nName: Is_Fraud, dtype: float64\n\nDevice_Type Analysis:\nDevice_Type\nATM        5.0\nDesktop    5.1\nMobile     5.0\nPOS        5.1\nName: Is_Fraud, dtype: float64\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"stage-4---convert-date-time-columns-to-numerical-columns",children:"Stage 4 - Convert Date Time Columns to Numerical Columns"}),"\n",(0,i.jsx)(e.p,{children:"Convert 'Transaction_Date' and 'Transaction_Time' to datetime"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df['Transaction_Date'] = pd.to_datetime(df['Transaction_Date'], format='%d-%m-%Y')\ndf['Transaction_Time'] = pd.to_datetime(df['Transaction_Time'], format='%H:%M:%S')\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Extract new features from 'Transaction_Date' and 'Transaction_Time'\ndf['Transaction_Day'] = df['Transaction_Date'].dt.day\ndf['Transaction_Month'] = df['Transaction_Date'].dt.month\ndf['Transaction_Year'] = df['Transaction_Date'].dt.year\ndf['Transaction_Hour'] = df['Transaction_Time'].dt.hour\ndf['Transaction_Minute'] = df['Transaction_Time'].dt.minute\ndf['Transaction_Second'] = df['Transaction_Time'].dt.second\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Drop 'Transaction_Date' and 'Transaction_Time' columns after feature extraction\ndf = df.drop(columns=['Transaction_Date', 'Transaction_Time'])\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# If a column has only one unique value, it won\'t be useful for prediction.\nsingle_value_cols = [col for col in df.columns if df[col].nunique() == 1]\nprint("Columns with only one unique value:", single_value_columns)\n\n# Dropping columns with one unique value\ndf = df.drop(columns=single_value_cols)\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-17",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Columns with only one unique value: ['Transaction_Currency']\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# For numerical columns, updating after conversion\nnumerical_columns = df.select_dtypes(include=['float64', 'int64']).columns\nprint(\"Numerical Columns ::\", numerical_columns)\nprint(\"-\"*50)\n# For categorical columns, updating after conversion\ncategorical_columns = df.select_dtypes(include=['object']).columns\nprint(\"Categorical Columns ::\", categorical_columns)\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-18",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\nNumerical Columns :: Index(['Age', 'Transaction_Amount', 'Account_Balance', 'Is_Fraud'], dtype='object')\n--------------------------------------------------\nCategorical Columns :: Index(['Gender', 'State', 'City', 'Bank_Branch', 'Account_Type',\n       'Transaction_Type', 'Merchant_Category', 'Transaction_Device',\n       'Transaction_Location', 'Device_Type', 'Transaction_Description'],\n      dtype='object')\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.head()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-19",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\n \tGender \tAge \tState        City                 Bank_Branch                   Account_Type \tTransaction_Amount  Transaction_Type    Merchant_Category    Account_Balance   Transaction_Device   Transaction_Location        Device_Type \tIs_Fraud    Transaction_Description   Transaction_Day   Transaction_Hour   Transaction_Minute   Transaction_Second\n0 \tMale \t60      Kerala       Thiruvananthapuram   Thiruvananthapuram Branch     Savings         32415.45            Transfer            Restaurant           74557.27          Voice Assistant      Thiruvananthapuram, Kerala  POS             0           Bitcoin transaction       23                16                 4                     7\n1 \tFemale \t51      Maharashtra  Nashik \t          Nashik Branch                 Business        43622.60            Bill Payment        Restaurant           74622.66          POS Mobile Device    Nashik, Maharashtra         Desktop         0           Grocery delivery          11                17                 14                    53\n2 \tMale \t20      Bihar        Bhagalpur            Bhagalpur Branch              Savings         63062.56            Bill Payment        Groceries            66817.99          ATM                  Bhagalpur, Bihar            Desktop         0           Mutual fund investment    25                3                  9                     52\n3 \tFemale \t57      Tamil Nadu   Chennai              Chennai Branch                Business        14000.72            Debit               Entertainment        58177.08          POS Mobile App       Chennai, Tamil Nadu         Mobile          0           Food delivery             19                12                 27                    2\n4 \tFemale \t43      Punjab       Amritsar             Amritsar Branch               Savings         18335.16            Transfer            Entertainment        16108.56          Virtual Card         Amritsar, Punjab            Mobile          0           Debt repayment            30                18                 30                    46\n"})}),"\n",(0,i.jsx)(e.h2,{id:"stage-5---encode-categorical-features",children:"Stage 5 - Encode Categorical Features"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Initializing the LabelEncoder\nlabel_encoder = LabelEncoder()\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"for col in categorical_columns:\n    df[col] = label_encoder.fit_transform(df[col])\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.head()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-20",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\n \tCustomer_ID                             Customer_Name       Gender \tAge    State        City                 Bank_Branch                 Account_Type   Transaction_ID                          Transaction_Date   ...   Merchant_Category   Account_Balance   Transaction_Device   Transaction_Location          Device_Type   Is_Fraud   Transaction_Currency   Customer_Contact   Transaction_Description   Customer_Email\n0 \td5f6ec07-d69e-4f47-b9b4-7c58ff17c19e    Osha Tella          Male \t60     Kerala       Thiruvananthapuram   Thiruvananthapuram Branch   Savings        4fa3208f-9e23-42dc-b330-844829d0c12c    23-01-2025         ...   Restaurant          74557.27          Voice Assistant      Thiruvananthapuram, Kerala    POS           0          INR                    +9198579XXXXXX     Bitcoin transaction       oshaXXXXX@XXXXX.com\n1 \t7c14ad51-781a-4db9-b7bd-67439c175262    Hredhaan Khosla     Female \t51     Maharashtra  Nashik               Nashik Branch               Business       c9de0c06-2c4c-40a9-97ed-3c7b8f97c79c    11-01-2025         ...   Restaurant          74622.66          POS Mobile Device    Nashik, Maharashtra           Desktop       0          INR                    +9191074XXXXXX     Grocery delivery          hredhaanXXXX@XXXXXX.com\n2 \t3a73a0e5-d4da-45aa-85f3-528413900a35    Ekani Nazareth      Male \t20     Bihar        Bhagalpur            Bhagalpur Branch            Savings        e41c55f9-c016-4ff3-872b-cae72467c75c    25-01-2025         ...   Groceries           66817.99          ATM                  Bhagalpur, Bihar              Desktop       0          INR                    +9197745XXXXXX     Mutual fund investment    ekaniXXX@XXXXXX.com\n3 \t7902f4ef-9050-4a79-857d-9c2ea3181940    Yamini Ramachandran Female \t57     Tamil Nadu   Chennai              Chennai Branch              Business       7f7ee11b-ff2c-45a3-802a-49bc47c02ecb    19-01-2025         ...   Entertainment       58177.08          POS Mobile App       Chennai, Tamil Nadu           Mobile        0          INR                    +9195889XXXXXX     Food delivery             yaminiXXXXX@XXXXXXX.com\n4 \t3a4bba70-d9a9-4c5f-8b92-1735fd8c19e9    Kritika Rege        Female \t43     Punjab       Amritsar             Amritsar Branch             Savings        f8e6ac6f-81a1-4985-bf12-f60967d852ef    30-01-2025         ...   Entertainment       16108.56          Virtual Card         Amritsar, Punjab              Mobile        0          INR                    +9195316XXXXXX     Debt repayment            kritikaXXXX@XXXXXX.com\n\n5 rows \xd7 24 columns\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.info()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-21",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 200000 entries, 0 to 199999\nData columns (total 19 columns):\n #   Column                   Non-Null Count   Dtype\n---  ------                   --------------   -----\n 0   Gender                   200000 non-null  int64\n 1   Age                      200000 non-null  int64\n 2   State                    200000 non-null  int64\n 3   City                     200000 non-null  int64\n 4   Bank_Branch              200000 non-null  int64\n 5   Account_Type             200000 non-null  int64\n 6   Transaction_Amount       200000 non-null  float64\n 7   Transaction_Type         200000 non-null  int64\n 8   Merchant_Category        200000 non-null  int64\n 9   Account_Balance          200000 non-null  float64\n 10  Transaction_Device       200000 non-null  int64\n 11  Transaction_Location     200000 non-null  int64\n 12  Device_Type              200000 non-null  int64\n 13  Is_Fraud                 200000 non-null  int64\n 14  Transaction_Description  200000 non-null  int64\n 15  Transaction_Day          200000 non-null  int32\n 16  Transaction_Hour         200000 non-null  int32\n 17  Transaction_Minute       200000 non-null  int32\n 18  Transaction_Second       200000 non-null  int32\ndtypes: float64(2), int32(4), int64(13)\nmemory usage: 25.9 MB\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"df.nunique()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-22",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Gender                          2\nAge                            53\nState                          34\nCity                          145\nBank_Branch                   145\nAccount_Type                    3\nTransaction_Amount         197978\nTransaction_Type                5\nMerchant_Category               6\nAccount_Balance            197954\nTransaction_Device             20\nTransaction_Location          148\nDevice_Type                     4\nIs_Fraud                        2\nTransaction_Description       172\nTransaction_Day                31\nTransaction_Hour               24\nTransaction_Minute             60\nTransaction_Second             60\ndtype: int64\n"})}),"\n",(0,i.jsx)(e.h2,{id:"stage-6---eda-after-label-encoder",children:"Stage 6 - EDA after Label Encoder"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Filter numerical columns with less than 20 unique values\nnumerical_features = df.select_dtypes(include=['float64', 'int64']).columns\nnumerical_features = [col for col in numerical_features if df[col].nunique() < 200]\n\n# Set the number of charts per row\nnum_cols = 2  # Number of charts per row\n\n# Calculate the number of rows needed based on the number of features\nnum_rows = (len(numerical_features) + num_cols - 1) // num_cols  # This ensures enough rows are created\n\n# Create a figure with the appropriate number of rows and columns\nplt.figure(figsize=(15, 5 * num_rows))\n\n# Plot the histograms for the filtered numerical columns\nfor i, feature in enumerate(numerical_features):\n    plt.subplot(num_rows, num_cols, i + 1)\n    sns.histplot(data=df, x=feature, hue='Is_Fraud', bins=30)\n    plt.title(f'{feature} Distribution by Churn Status')\n\nplt.tight_layout()\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-23",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/33-distribution.png",alt:"33-distribution.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/34-distribution.png",alt:"34-distribution.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/35-distribution.png",alt:"35-distribution.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/36-distribution.png",alt:"36-distribution.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/37-distribution.png",alt:"37-distribution.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/38-distribution.png",alt:"38-distribution.png"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/39-distribution.png",alt:"39-distribution.png"}),"\n",(0,i.jsx)(e.h2,{id:"stage-7---visualize-fraud-patterns-and-distribution-of-features",children:"Stage 7 - Visualize Fraud Patterns and Distribution of Features"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Create a figure with 2 subplots in a horizontal row\nfig, axes = plt.subplots(1, 2, figsize=(15, 6))  # 1 row, 2 columns\n\n# KDE plot for the 'Is_Fraud' column (on the first subplot)\nsns.kdeplot(df[\"Is_Fraud\"], fill=True, ax=axes[0])\naxes[0].set_title('Target Variable Distribution')\n\n# Count plot for the 'Is_Fraud' column (on the second subplot)\nsns.countplot(x='Is_Fraud', data=df, ax=axes[1])\naxes[1].set_title('Fraudulent Transactions Count')\n\n# Adjust layout to prevent overlap\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-24",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/40-plot-for-fraud.png",alt:"40-plot-for-fraud.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Visualize fraud transactions based on 'Transaction_Amount'\nplt.figure(figsize=(12, 6))\nsns.boxplot(x='Is_Fraud', y='Transaction_Amount', data=df)\nplt.title(\"Transaction Amount vs Fraud/Non-Fraud\")\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-25",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/41-fraud-on-transaction-amount.png",alt:"41-fraud-on-transaction-amount.png"}),"\n",(0,i.jsx)(e.h2,{id:"stage-8---plot-correlation-matrix-to-understand-feature-relationships",children:"Stage 8 - Plot Correlation Matrix to Understand Feature Relationships"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'plt.figure(figsize=(14, 10))\ncorrelation_matrix = df.corr()\nsns.heatmap(correlation_matrix, annot=True, cmap=\'coolwarm\', fmt=".2f")\nplt.title("Correlation Matrix")\nplt.show()\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-26",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/42-correlation-matrix.png",alt:"42-correlation-matrix.png"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Calculate correlation matrix for numerical columns\ncorrelation_matrix = df.corr()\n\n# Extract correlation with 'Exited' and drop 'Exited' itself\ncorrelation_price = correlation_matrix['Is_Fraud'].sort_values(ascending=False).drop('Is_Fraud')\n\n# Plot the heatmap for the correlation with 'Exited'\nplt.figure(figsize=(8, 5))\nsns.heatmap(correlation_price.to_frame(), annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)\nplt.title('Correlation with Exited')\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-27",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/43-correlation-with-exited.png",alt:"43-correlation-with-exited.png"}),"\n",(0,i.jsx)(e.h2,{id:"stage-9---feature-importance-using-random-forest",children:"Stage 9 - Feature Importance using Random Forest"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"rf = RandomForestClassifier(n_estimators=100, random_state=42)\nX = df.drop(columns=['Is_Fraud'])\ny = df['Is_Fraud']\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'print("Shape for X Dataframe: ", X.shape)\nprint("Columns for X Dataframe: ", X.columns)\nprint("-"*50)\nprint("Shape for y Dataframe: ", y.shape)\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-28",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Shape for y Dataframe:  (200000,)\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Train the model\nrf.fit(X, y)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Get feature importances\nfeature_importances = pd.DataFrame(rf.feature_importances_, index=X.columns, columns=['importance'])\nfeature_importances = feature_importances.sort_values('importance', ascending=False)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Plot feature importances\nplt.figure(figsize=(12, 8))\nfeature_importances.head(20).plot(kind='bar', figsize=(10, 6))\nplt.title(\"Top 20 Feature Importances\")\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-29",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/44-top-20-feature-importances.png",alt:"44-top-20-feature-importances.png"}),"\n",(0,i.jsx)(e.h2,{id:"stage-10---select-only-important-features",children:"Stage 10 - Select Only Important Features"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# Select features with importance greater than a threshold (e.g., 0.01)\nimportant_features = feature_importances[feature_importances[\'importance\'] > 0.01].index\nX = df[important_features]\nprint("Shape for X Dataframe: ", X.shape)\nprint("Columns for X Dataframe: ", X.columns)\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-30",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Shape for X Dataframe:  (200000, 18)\nColumns for X Dataframe:  Index(['Transaction_Amount', 'Account_Balance', 'Transaction_Description',\n       'Transaction_Second', 'Transaction_Minute', 'Age', 'Transaction_Day',\n       'Transaction_Hour', 'Transaction_Device', 'Transaction_Location',\n       'State', 'City', 'Bank_Branch', 'Merchant_Category', 'Transaction_Type',\n       'Device_Type', 'Account_Type', 'Gender'],\n      dtype='object')\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"stage-11---perform-pca-principal-component-analysis",children:"Stage 11 - Perform PCA (Principal Component Analysis)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-#",metastring:"If the number of features is large, PCA can help reduce dimensions",children:"   pca = PCA(n_components=2)  # Reducing to 2 components for visualization\n   X_pca = pca.fit_transform(X)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# Plot PCA results\nplt.figure(figsize=(8, 6))\nplt.scatter(X_pca[:, 0], X_pca[:, 1], c=y, cmap=\'coolwarm\')\nplt.title("PCA of Important Features")\nplt.xlabel("Principal Component 1")\nplt.ylabel("Principal Component 2")\nplt.colorbar(label=\'Fraud (1) vs Non-Fraud (0)\')\nplt.show()\n'})}),"\n",(0,i.jsx)(e.h4,{id:"output-31",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/45-PCA-of-important-features.png",alt:"45-PCA-of-important-features.png"}),"\n",(0,i.jsx)(e.h2,{id:"stage-12---train-test-split",children:"Stage 12 - Train-test Split"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"stage-13---feature-scaling",children:"Stage 13 - Feature Scaling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"scaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"stage-14---model-training-and-evaluation",children:"Stage 14 - Model Training and Evaluation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Define models\nmodels = {\n    'Logistic Regression': LogisticRegression(),\n    'Decision Tree': DecisionTreeClassifier(),\n    'Random Forest': RandomForestClassifier(),\n    'Gradient Boosting': GradientBoostingClassifier(),\n    'XGBoost': xgb.XGBClassifier(),\n    'LightGBM': lgb.LGBMClassifier(),\n    'CatBoost': cb.CatBoostClassifier(silent=True),\n    'AdaBoost': AdaBoostClassifier(),\n    'Bagging': BaggingClassifier(),\n    'KNN': KNeighborsClassifier()\n    # 'SVM (RBF)': SVC(kernel='rbf', probability=True),\n    # 'SVM (Linear)': LinearSVC(),\n    # 'GaussianNB': GaussianNB()\n    # 'LDA': LDA(),\n    # 'QDA': QuadraticDiscriminantAnalysis(),\n    # 'Ridge Classifier': RidgeClassifier(),\n}\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Define reduced parameter grids\nparam_grids = {\n    'Logistic Regression': {\n        'C': [0.1, 1],\n        'solver': ['liblinear'],\n        'penalty': ['l2']\n    },\n    'Decision Tree': {\n        'max_depth': [5, 10],\n        'min_samples_split': [2, 5],\n        'min_samples_leaf': [1, 2]\n    },\n    'Random Forest': {\n        'n_estimators': [50, 100],\n        'max_depth': [10],\n        'min_samples_split': [2],\n        'min_samples_leaf': [1]\n    },\n    'Gradient Boosting': {\n        'n_estimators': [100],\n        'learning_rate': [0.1],\n        'max_depth': [5]\n    },\n    'XGBoost': {\n        'n_estimators': [100],\n        'learning_rate': [0.1],\n        'max_depth': [5],\n        'subsample': [0.8, 1.0]\n    },\n    'SVM (RBF)': {\n        'C': [1, 10],\n        'gamma': ['scale', 'auto']\n    },\n    'SVM (Linear)': {\n        'C': [1, 10],\n    },\n    'LightGBM': {\n        'n_estimators': [100],\n        'learning_rate': [0.1],\n        'max_depth': [3, 5],\n    },\n    'CatBoost': {\n        'iterations': [100],\n        'learning_rate': [0.1],\n        'depth': [3, 5]\n    },\n    'KNN': {\n        'n_neighbors': [3],\n        'weights': ['uniform', 'distance']\n    },\n    'AdaBoost': {\n        'n_estimators': [100],\n        'learning_rate': [0.01, 0.1]\n    },\n    'Bagging': {\n        'n_estimators': [100],\n        'max_samples': [0.8, 1.0]\n    },\n    'LDA': {},\n    'QDA': {},\n    'Ridge Classifier': {\n        'alpha': [0.1, 1]\n    },\n    'GaussianNB': {}\n}\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# Initialize an empty dictionary to store results\nmodel_results = {}\n\n# Handle class imbalance by computing class weights for each model that supports it\nclass_weights = compute_class_weight('balanced', classes=np.array([0, 1]), y=y_train)\nclass_weight_dict = {0: class_weights[0], 1: class_weights[1]}\nprint(\"class_weight_dict: \", class_weight_dict)\n\n# Handle SMOTE for class imbalance\nsmote = SMOTE(sampling_strategy='auto', random_state=42)\nX_train_smote, y_train_smote = smote.fit_resample(X_train_scaled, y_train)\n\n# Evaluate models with GridSearchCV\nfor model_name, model in models.items():\n    print(f\"Training model with GridSearchCV: {model_name}\")\n\n    # Get the parameter grid for the model\n    param_grid = param_grids[model_name]\n\n    # Modify model to include class weights where applicable\n    if model_name in ['Logistic Regression', 'Random Forest', 'SVM (RBF)', 'SVM (Linear)']:\n        # Assign class weights for models that support it\n        if model_name == 'Logistic Regression':\n            model = LogisticRegression(class_weight='balanced')\n        elif model_name == 'Random Forest':\n            model = RandomForestClassifier(class_weight='balanced')\n        elif model_name in ['SVM (RBF)', 'SVM (Linear)']:\n            model = SVC(probability=True, class_weight='balanced') if model_name == 'SVM (RBF)' else LinearSVC(class_weight='balanced')\n\n    # Perform GridSearchCV with parallelism\n    grid_search = GridSearchCV(estimator=model, param_grid=param_grid, cv=3, n_jobs=-1, verbose=2)\n\n    # Fit the model with the best parameters using the resampled data\n    grid_search.fit(X_train_smote, y_train_smote)\n\n    # Get the best model and its parameters\n    best_model = grid_search.best_estimator_\n    print(f\"Best parameters for {model_name}: {grid_search.best_params_}\")\n\n    # Predict on both train and test sets\n    y_train_pred = best_model.predict(X_train_smote)\n    y_test_pred = best_model.predict(X_test_scaled)\n\n    # Store the results\n    model_results[model_name] = {\n        'train_accuracy': best_model.score(X_train_smote, y_train_smote),\n        'test_accuracy': best_model.score(X_test_scaled, y_test),\n        'y_test': y_test,\n        'y_test_pred': y_test_pred,\n        'classification_report': classification_report(y_test, y_test_pred),\n        'roc_auc': roc_auc_score(y_test, best_model.predict_proba(X_test_scaled)[:, 1])\n    }\n\n    # Print results after all models are evaluated\n    print(\"\\nModel Evaluation Results:\")\n    print(f\"Model: {model_results[model_name]}\\n\")\n    print(f\"Train Accuracy: {model_results[model_name]['train_accuracy']:.4f}\")\n    print(f\"Test Accuracy: {model_results[model_name]['test_accuracy']:.4f}\")\n    print(f\"ROC AUC: {model_results[model_name]['roc_auc']:.4f}\\n\")\n    print(f\"Classification Report:\\n{model_results[model_name]['classification_report']}\")\n    print(\"-\" * 80)\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-32",children:"Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"class_weight_dict:  {0: 0.5264647235731161, 1: 9.946537361680965}\n\nTraining model with GridSearchCV: Logistic Regression\n-----------------------------------------------------\nFitting 3 folds for each of 2 candidates, totalling 6 fits\nBest parameters for Logistic Regression: {'C': 0.1, 'penalty': 'l2', 'solver': 'liblinear'}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.5110919536447811, 'test_accuracy': 0.509575, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 1, 1, ..., 1, 1, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      0.51      0.66     37955\\n           1       0.05      0.50      0.09      2045\\n\\n    accuracy                           0.51     40000\\n   macro avg       0.50      0.50      0.38     40000\\nweighted avg       0.90      0.51      0.63     40000\\n', 'roc_auc': 0.49595028728847923}\n\nTrain Accuracy: 0.5111\nTest Accuracy: 0.5096\nROC AUC: 0.4960\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      0.51      0.66     37955\n           1       0.05      0.50      0.09      2045\n\n    accuracy                           0.51     40000\n   macro avg       0.50      0.50      0.38     40000\nweighted avg       0.90      0.51      0.63     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: Decision Tree\n-----------------------------------------------\nFitting 3 folds for each of 8 candidates, totalling 24 fits\nBest parameters for Decision Tree: {'max_depth': 10, 'min_samples_leaf': 2, 'min_samples_split': 5}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.8582065979191482, 'test_accuracy': 0.946825, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      1.00      0.97     37955\\n           1       0.02      0.00      0.00      2045\\n\\n    accuracy                           0.95     40000\\n   macro avg       0.49      0.50      0.49     40000\\nweighted avg       0.90      0.95      0.92     40000\\n', 'roc_auc': 0.4977343714519736}\n\nTrain Accuracy: 0.8582\nTest Accuracy: 0.9468\nROC AUC: 0.4977\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.97     37955\n           1       0.02      0.00      0.00      2045\n\n    accuracy                           0.95     40000\n   macro avg       0.49      0.50      0.49     40000\nweighted avg       0.90      0.95      0.92     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: Random Forest\n-----------------------------------------------\nFitting 3 folds for each of 2 candidates, totalling 6 fits\nBest parameters for Random Forest: {'max_depth': 10, 'min_samples_leaf': 1, 'min_samples_split': 2, 'n_estimators': 50}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.8498127759826793, 'test_accuracy': 0.85335, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      0.89      0.92     37955\\n           1       0.05      0.11      0.07      2045\\n\\n    accuracy                           0.85     40000\\n   macro avg       0.50      0.50      0.50     40000\\nweighted avg       0.90      0.85      0.88     40000\\n', 'roc_auc': 0.5063503975722118}\n\nTrain Accuracy: 0.8498\nTest Accuracy: 0.8534\nROC AUC: 0.5064\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      0.89      0.92     37955\n           1       0.05      0.11      0.07      2045\n\n    accuracy                           0.85     40000\n   macro avg       0.50      0.50      0.50     40000\nweighted avg       0.90      0.85      0.88     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: Gradient Boosting\n---------------------------------------------------\nFitting 3 folds for each of 1 candidates, totalling 3 fits\n[CV] END max_depth=5, min_samples_leaf=1, min_samples_split=2; total time=   1.8s\n[CV] END max_depth=5, min_samples_leaf=1, min_samples_split=2; total time=   2.0s\n[CV] END max_depth=5, min_samples_leaf=2, min_samples_split=5; total time=   1.8s\n[CV] END max_depth=5, min_samples_leaf=2, min_samples_split=5; total time=   1.9s\n[CV] END max_depth=5, min_samples_leaf=1, min_samples_split=5; total time=   1.7s\n[CV] END max_depth=5, min_samples_leaf=1, min_samples_split=5; total time=   2.0s\n[CV] END max_depth=5, min_samples_leaf=1, min_samples_split=2; total time=   1.9s\n[CV] END ................C=0.1, penalty=l2, solver=liblinear; total time=   0.3s\n[CV] END max_depth=10, min_samples_leaf=2, min_samples_split=5; total time=   2.6s\n[CV] END ..................C=1, penalty=l2, solver=liblinear; total time=   0.3s\n[CV] END max_depth=10, min_samples_leaf=2, min_samples_split=5; total time=   2.9s\n[CV] END max_depth=10, min_samples_leaf=2, min_samples_split=5; total time=   2.5s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2; total time=   2.6s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=5; total time=   2.6s\n[CV] END max_depth=10, min_samples_leaf=2, min_samples_split=2; total time=   2.6s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=5; total time=   2.6s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=5; total time=   2.7s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2; total time=   2.7s\n[CV] END max_depth=10, min_samples_leaf=2, min_samples_split=2; total time=   2.7s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2; total time=   2.8s\n[CV] END max_depth=10, min_samples_leaf=2, min_samples_split=2; total time=   2.8s\n[CV] END ..................C=1, penalty=l2, solver=liblinear; total time=   0.7s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2, n_estimators=50; total time=  19.5s\n[CV] END ................C=0.1, penalty=l2, solver=liblinear; total time=   0.6s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2, n_estimators=50; total time=  19.7s\n[CV] END ................C=0.1, penalty=l2, solver=liblinear; total time=   0.6s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2, n_estimators=50; total time=  19.8s\n[CV] END max_depth=5, min_samples_leaf=2, min_samples_split=2; total time=   1.7s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2, n_estimators=100; total time=  37.4s\n[CV] END max_depth=5, min_samples_leaf=1, min_samples_split=5; total time=   1.6s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2, n_estimators=100; total time=  37.4s\n[CV] END ..................C=1, penalty=l2, solver=liblinear; total time=   0.8s\n[CV] END max_depth=10, min_samples_leaf=1, min_samples_split=2, n_estimators=100; total time=  38.3s\nBest parameters for Gradient Boosting: {'learning_rate': 0.1, 'max_depth': 5, 'n_estimators': 100}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.9527168870140895, 'test_accuracy': 0.948875, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      1.00      0.97     37955\\n           1       0.00      0.00      0.00      2045\\n\\n    accuracy                           0.95     40000\\n   macro avg       0.47      0.50      0.49     40000\\nweighted avg       0.90      0.95      0.92     40000\\n', 'roc_auc': 0.5045642649141516}\n\nTrain Accuracy: 0.9527\nTest Accuracy: 0.9489\nROC AUC: 0.5046\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.97     37955\n           1       0.00      0.00      0.00      2045\n\n    accuracy                           0.95     40000\n   macro avg       0.47      0.50      0.49     40000\nweighted avg       0.90      0.95      0.92     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: XGBoost\nFitting 3 folds for each of 2 candidates, totalling 6 fits\nBest parameters for XGBoost: {'learning_rate': 0.1, 'max_depth': 5, 'n_estimators': 100, 'subsample': 1.0}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.9471528129668262, 'test_accuracy': 0.948875, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      1.00      0.97     37955\\n           1       0.00      0.00      0.00      2045\\n\\n    accuracy                           0.95     40000\\n   macro avg       0.47      0.50      0.49     40000\\nweighted avg       0.90      0.95      0.92     40000\\n', 'roc_auc': 0.49996872502793327}\n\nTrain Accuracy: 0.9472\nTest Accuracy: 0.9489\nROC AUC: 0.5000\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.97     37955\n           1       0.00      0.00      0.00      2045\n\n    accuracy                           0.95     40000\n   macro avg       0.47      0.50      0.49     40000\nweighted avg       0.90      0.95      0.92     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: LightGBM\n------------------------------------------\n[LightGBM] [Info] Number of positive: 151957, number of negative: 151957\n[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.002153 seconds.\nYou can set `force_row_wise=true` to remove the overhead.\nAnd if memory is not enough, you can set `force_col_wise=true`.\n[LightGBM] [Info] Total Bins 4584\n[LightGBM] [Info] Number of data points in the train set: 303914, number of used features: 18\n[LightGBM] [Info] [binary:BoostFromScore]: pavg=0.500000 -> initscore=0.000000\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\nBest parameters for LightGBM: {'learning_rate': 0.1, 'max_depth': 5, 'n_estimators': 100}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.9520357732779668, 'test_accuracy': 0.948875, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      1.00      0.97     37955\\n           1       0.00      0.00      0.00      2045\\n\\n    accuracy                           0.95     40000\\n   macro avg       0.47      0.50      0.49     40000\\nweighted avg       0.90      0.95      0.92     40000\\n', 'roc_auc': 0.4997815261220097}\n\nTrain Accuracy: 0.9520\nTest Accuracy: 0.9489\nROC AUC: 0.4998\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.97     37955\n           1       0.00      0.00      0.00      2045\n\n    accuracy                           0.95     40000\n   macro avg       0.47      0.50      0.49     40000\nweighted avg       0.90      0.95      0.92     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: CatBoost\n-------------------------------------------\nFitting 3 folds for each of 2 candidates, totalling 6 fits\nBest parameters for CatBoost: {'depth': 5, 'iterations': 100, 'learning_rate': 0.1}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.9496864244490217, 'test_accuracy': 0.948875, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      1.00      0.97     37955\\n           1       0.00      0.00      0.00      2045\\n\\n    accuracy                           0.95     40000\\n   macro avg       0.47      0.50      0.49     40000\\nweighted avg       0.90      0.95      0.92     40000\\n', 'roc_auc': 0.49888715854800386}\n\nTrain Accuracy: 0.9497\nTest Accuracy: 0.9489\nROC AUC: 0.4989\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.97     37955\n           1       0.00      0.00      0.00      2045\n\n    accuracy                           0.95     40000\n   macro avg       0.47      0.50      0.49     40000\nweighted avg       0.90      0.95      0.92     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: AdaBoost\n------------------------------------------\nFitting 3 folds for each of 2 candidates, totalling 6 fits\n[CV] END max_depth=5, min_samples_leaf=2, min_samples_split=2; total time=   1.7s\n[CV] END ...learning_rate=0.1, max_depth=5, n_estimators=100; total time= 2.2min\n[CV] END learning_rate=0.1, max_depth=5, n_estimators=100, subsample=0.8; total time=   1.2s\n[CV] END max_depth=5, min_samples_leaf=2, min_samples_split=2; total time=   1.7s\n[CV] END ...learning_rate=0.1, max_depth=5, n_estimators=100; total time= 2.3min\n[CV] END learning_rate=0.1, max_depth=5, n_estimators=100, subsample=0.8; total time=   1.3s\n[CV] END max_depth=5, min_samples_leaf=2, min_samples_split=5; total time=   1.7s\n[CV] END ...learning_rate=0.1, max_depth=5, n_estimators=100; total time= 2.3min\n[CV] END learning_rate=0.1, max_depth=5, n_estimators=100, subsample=0.8; total time=   1.3s\n[CV] END learning_rate=0.1, max_depth=5, n_estimators=100, subsample=1.0; total time=   1.2s\n[CV] END learning_rate=0.1, max_depth=5, n_estimators=100, subsample=1.0; total time=   1.3s\n[CV] END learning_rate=0.1, max_depth=5, n_estimators=100, subsample=1.0; total time=   1.3s\nBest parameters for AdaBoost: {'learning_rate': 0.1, 'n_estimators': 100}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.629306316918602, 'test_accuracy': 0.486475, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 1, 1, 1]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      0.48      0.64     37955\\n           1       0.05      0.52      0.09      2045\\n\\n    accuracy                           0.49     40000\\n   macro avg       0.50      0.50      0.37     40000\\nweighted avg       0.90      0.49      0.61     40000\\n', 'roc_auc': 0.5060679179017489}\n\nTrain Accuracy: 0.6293\nTest Accuracy: 0.4865\nROC AUC: 0.5061\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      0.48      0.64     37955\n           1       0.05      0.52      0.09      2045\n\n    accuracy                           0.49     40000\n   macro avg       0.50      0.50      0.37     40000\nweighted avg       0.90      0.49      0.61     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: Bagging\n-----------------------------------------\nFitting 3 folds for each of 2 candidates, totalling 6 fits\n[CV] END .........depth=3, iterations=100, learning_rate=0.1; total time=   2.1s\n[CV] END .........depth=3, iterations=100, learning_rate=0.1; total time=   2.1s\n[CV] END .........depth=3, iterations=100, learning_rate=0.1; total time=   2.2s\n[CV] END .........depth=5, iterations=100, learning_rate=0.1; total time=   2.3s\n[CV] END .........depth=5, iterations=100, learning_rate=0.1; total time=   2.3s\n[CV] END .........depth=5, iterations=100, learning_rate=0.1; total time=   2.3s\n[CV] END ...............learning_rate=0.01, n_estimators=100; total time=  33.5s\n[CV] END ................learning_rate=0.1, n_estimators=100; total time=  33.7s\n[CV] END ................learning_rate=0.1, n_estimators=100; total time=  33.9s\n[CV] END ...............learning_rate=0.01, n_estimators=100; total time=  34.0s\n[CV] END ...............learning_rate=0.01, n_estimators=100; total time=  34.9s\n[CV] END ................learning_rate=0.1, n_estimators=100; total time=  35.0s\n[LightGBM] [Info] Number of positive: 101305, number of negative: 101305\n[LightGBM] [Info] Auto-choosing col-wise multi-threading, the overhead of testing was 0.157509 seconds.\n\n...\n\n### ----------------\n### ---- more details - see notebook for this cell\n### -----------------\n\n...\n\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[LightGBM] [Warning] No further splits with positive gain, best gain: -inf\n[CV] END ...learning_rate=0.1, max_depth=5, n_estimators=100; total time= 3.4min\n[CV] END ..................max_samples=1.0, n_estimators=100; total time= 3.4min\n\nModel Evaluation Results:\nModel: {'train_accuracy': 0.999990128786433, 'test_accuracy': 0.948725, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 0, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      1.00      0.97     37955\\n           1       0.00      0.00      0.00      2045\\n\\n    accuracy                           0.95     40000\\n   macro avg       0.47      0.50      0.49     40000\\nweighted avg       0.90      0.95      0.92     40000\\n', 'roc_auc': 0.5051717981562905}\n\nTrain Accuracy: 1.0000\nTest Accuracy: 0.9487\nROC AUC: 0.5052\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.97     37955\n           1       0.00      0.00      0.00      2045\n\n    accuracy                           0.95     40000\n   macro avg       0.47      0.50      0.49     40000\nweighted avg       0.90      0.95      0.92     40000\n"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Training model with GridSearchCV: KNN\n-------------------------------------\nFitting 3 folds for each of 2 candidates, totalling 6 fits\nBest parameters for KNN: {'n_neighbors': 3, 'weights': 'distance'}\n\nModel Evaluation Results:\nModel: {'train_accuracy': 1.0, 'test_accuracy': 0.7367, 'y_test': 119737    0\n72272     0\n158154    0\n65426     0\n30074     0\n         ..\n4174      0\n91537     0\n156449    0\n184376    0\n6584      0\nName: Is_Fraud, Length: 40000, dtype: int64, 'y_test_pred': array([0, 0, 1, ..., 0, 0, 0]), 'classification_report': '              precision    recall  f1-score   support\\n\\n           0       0.95      0.76      0.85     37955\\n           1       0.05      0.23      0.08      2045\\n\\n    accuracy                           0.74     40000\\n   macro avg       0.50      0.50      0.46     40000\\nweighted avg       0.90      0.74      0.81     40000\\n', 'roc_auc': 0.4954215631108644}\n\nTrain Accuracy: 1.0000\nTest Accuracy: 0.7367\nROC AUC: 0.4954\n\nClassification Report:\n              precision    recall  f1-score   support\n\n           0       0.95      0.76      0.85     37955\n           1       0.05      0.23      0.08      2045\n\n    accuracy                           0.74     40000\n   macro avg       0.50      0.50      0.46     40000\nweighted avg       0.90      0.74      0.81     40000\n"})}),"\n",(0,i.jsx)(e.h2,{id:"stage-15---displaying-evaluation-results-for-all-models",children:"Stage 15 - Displaying Evaluation Results for All Models"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'# # Print results after all models are evaluated\n# print("\\nModel Evaluation Results:")\n# print(f"Model: {model_results[model_name]}\\n")\n# print(f"Train Accuracy: {model_results[model_name][\'train_accuracy\']:.4f}")\n# print(f"Test Accuracy: {model_results[model_name][\'test_accuracy\']:.4f}")\n# print(f"ROC AUC: {model_results[model_name][\'roc_auc\']:.4f}\\n")\n# print(f"Classification Report:\\n{model_results[model_name][\'classification_report\']}")\n# print("-" * 80)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"stage-16---plotting-the-train-vs-test-accuracy-chart",children:"Stage 16 - Plotting the Train Vs Test Accuracy Chart"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc\n\n# Initialize a list to store results for all models\nresults_list = []\n\n# Iterate through the models to collect results and plot confusion matrix and ROC curve\nfor model_name, model in model_results.items():\n    # Extract the predicted values and actual values\n    y_test_pred = model['y_test_pred']  # Use the predicted labels\n    y_test = model['y_test']  # Actual true labels\n\n    # Extract metrics\n    train_accuracy = model['train_accuracy']\n    test_accuracy = model['test_accuracy']\n    roc_auc = model['roc_auc']\n\n    # Classification Report\n    clf_report = classification_report(y_test, y_test_pred)\n\n    # Print the model name followed by its evaluation metrics\n    print(\"-\" * 40)\n    print(f\"Model: {model_name}\")\n    print(\"-\" * 40)\n    print(f\"Train Accuracy: {train_accuracy:.4f}\")\n    print(f\"Test Accuracy: {test_accuracy:.4f}\")\n    print(f\"ROC AUC: {roc_auc:.4f}\")\n    print(\"Classification Report:\")\n    print(clf_report)\n    print(\"-\" * 80)  # Separator line for clarity\n\n    # Generate confusion matrix\n    cm = confusion_matrix(y_test, y_test_pred)\n\n    # ROC Curve\n    fpr, tpr, _ = roc_curve(y_test, y_test_pred)\n    roc_auc_value = auc(fpr, tpr)\n\n    # Create subplots: 1 row, 2 columns\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))  # Width, Height\n\n    # Plot ROC Curve on the first subplot\n    ax1.plot(fpr, tpr, color='b', lw=2, label=f'ROC curve (area = {roc_auc_value:.2f})')\n    ax1.plot([0, 1], [0, 1], color='gray', linestyle='--')  # Random classifier line\n    ax1.set_xlim([0.0, 1.0])\n    ax1.set_ylim([0.0, 1.05])\n    ax1.set_xlabel('False Positive Rate')\n    ax1.set_ylabel('True Positive Rate')\n    ax1.set_title(f'ROC Curve for {model_name}')\n    ax1.legend(loc='lower right')\n\n    # Plot Confusion Matrix on the second subplot\n    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',\n                xticklabels=['Predicted Negative', 'Predicted Positive'],\n                yticklabels=['Actual Negative', 'Actual Positive'], ax=ax2)\n    ax2.set_title(f'Confusion Matrix for {model_name}')\n    ax2.set_xlabel('Predicted')\n    ax2.set_ylabel('Actual')\n\n    # Show both plots\n    plt.tight_layout()\n    plt.show()\n\n    # Append the results to the list for the DataFrame\n    results_list.append({\n        'Model': model_name,\n        'Train Accuracy': f\"{train_accuracy:.4f}\",\n        'Test Accuracy': f\"{test_accuracy:.4f}\",\n        'ROC AUC': f\"{roc_auc:.4f}\",\n        'Classification Report': clf_report\n    })\n\n# Convert results into a DataFrame for better presentation\nresults_df = pd.DataFrame(results_list)\n\n# Print the summary of results in a tabular format\n# print(\"\\nSummary of Model Evaluation Results:\")\n# print(results_df.to_string(index=False))  # Display as a pretty table\nprint(\"-\" * 80)\n"})}),"\n",(0,i.jsx)(e.h4,{id:"output-33",children:"Output"}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/46-logistic-regression.png",alt:"46-logistic-regression.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/47-decision-tree.png",alt:"47-decision-tree.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/48-random-forest.png",alt:"48-random-forest.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/49-gradient-boosting.png",alt:"49-gradient-boosting.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/50-xgboost.png",alt:"50-xgboost.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/51-ligthgbm.png",alt:"51-ligthgbm.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/52-catboost.png",alt:"52-catboost.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/53-adaboost.png",alt:"53-adaboost.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/54-bagging.png",alt:"54-bagging.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/img/ai/machine-learning/fraud-detection/Bank-Transaction-Fraud-Detection-01/55-knn.png",alt:"55-knn.png"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.h2,{id:"stage-17---final-conclusion",children:"Stage 17 - Final Conclusion"}),"\n",(0,i.jsx)(e.h3,{id:"conclusion",children:"Conclusion:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"High Test Accuracy: The model achieved a high test accuracy, indicating that it correctly predicted most instances in the test set. This is a promising result for the overall performance of the model."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"ROC AUC: The ROC AUC is nearly 0.5, which is close to random guessing. This suggests that the model struggles to distinguish between the two classes effectively. The low ROC AUC indicates poor discriminative power, especially for class 1."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Class Imbalance: The classification report highlights a significant class imbalance."}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Class 0 (majority class) has a high precision of 0.95 and recall of 1.00, with an F1-score of 0.97, indicating that the model performs very well on class 0."}),"\n",(0,i.jsx)(e.li,{children:"Class 1 (minority class) has very low precision (0.02) and recall (0.00), with an F1-score of 0.00, indicating that the model struggles severely to identify the minority class (class 1)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Impact of Class Imbalance: The poor performance on class 1 suggests that the model may be biased towards predicting the majority class (class 0), and thus failing to identify the minority class. This is supported by the low recall and precision for class 1."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Model Improvement Suggestions:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Address Class Imbalance: Techniques such as resampling (SMOTE), class weights adjustment, or using more balanced metrics like F1-score for class 1 can help improve the model's ability to detect the minority class."}),"\n",(0,i.jsx)(e.li,{children:"Model Tuning: Exploring other models or hyperparameters to better balance accuracy across both classes may improve performance."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Final Remarks: While the model shows strong performance in terms of overall accuracy, it is heavily biased towards the majority class, which makes it unreliable for detecting the minority class. Addressing the class imbalance should be a priority for improving model performance in real-world scenarios."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"final-remarks",children:"Final Remarks:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"The model demonstrates strong overall accuracy, indicating its ability to correctly predict the majority of instances within the dataset."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"There is a noticeable discrepancy between training and testing accuracy, which may suggest some degree of overfitting, although the difference is not extreme."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"The ROC AUC score is close to random guessing, indicating that the model struggles with distinguishing between the two classes, especially for the minority class."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Class imbalance is a significant issue, as the model shows excellent performance on the majority class but fails to effectively identify the minority class."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Precision and recall for the majority class are very high, showcasing that the model can accurately predict this class without many false positives or negatives."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"The performance for the minority class is poor, with the model having difficulty detecting and correctly predicting instances of this class."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"The model's inability to perform well on the minority class suggests a bias toward the majority class, which reduces its overall usefulness in cases where detecting the minority class is important."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"There is an imbalance between the precision and recall of the two classes, with the model being much more sensitive to the majority class."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Improvements to the model should focus on addressing class imbalance, such as through resampling techniques, class weighting, or exploring alternative models that are more adept at handling skewed distributions."}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"The current model, while performing well on the majority class, needs further optimization and tuning to ensure it can reliably detect the minority class and be more robust across all categories."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"On the base + sources"})}),":",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(e.a,{href:"https://www.kaggle.com/code/marusagar/bank-transaction-fraud-detection-accuracy-95",children:(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"Bank Transaction Fraud Detection (Accuracy: 95%)"})})})," ",(0,i.jsx)("br",{})]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(n){const e=a.useContext(r);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),a.createElement(r.Provider,{value:e},n.children)}}}]);