"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[1910],{6576:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"streams/apache-spark/spark-architecture","title":"Spark Architecture","description":"Understanding Spark Architecture: How It All Comes Together","source":"@site/docs/streams/apache-spark/spark-architecture.mdx","sourceDirName":"streams/apache-spark","slug":"/streams/apache-spark/spark-architecture","permalink":"/docs/streams/apache-spark/spark-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":100,"frontMatter":{"sidebar_position":100},"sidebar":"tutorialSidebar","previous":{"title":"Apache Spark","permalink":"/docs/apache-spark"},"next":{"title":"Interactive Analysis with the Spark Shell","permalink":"/docs/streams/apache-spark/interactive-analysis-with-spark-shell"}}');var t=r(4848),n=r(8453);const i={sidebar_position:100},c="Spark Architecture",o={},l=[{value:"The Spark Driver (Master)",id:"the-spark-driver-master",level:3},{value:"<em><strong>sparkContext</strong></em>",id:"sparkcontext",level:3},{value:"The Spark Executors (Slaves)",id:"the-spark-executors-slaves",level:3},{value:"The Cluster Manager",id:"the-cluster-manager",level:3},{value:"Task",id:"task",level:3},{value:"RDD (Resilient Distributed Datasets)",id:"rdd-resilient-distributed-datasets",level:3},{value:"DAG (Directed Acyclic Graph)",id:"dag-directed-acyclic-graph",level:3},{value:"DAG Scheduler",id:"dag-scheduler",level:3},{value:"Task Scheduler",id:"task-scheduler",level:3},{value:"Built-in Libraries",id:"built-in-libraries",level:2}];function h(e){const s={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"spark-architecture",children:"Spark Architecture"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.a,{href:"https://medium.com/towards-data-engineering/understanding-spark-architecture-how-it-all-comes-together-5f2196b1fa8a",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Understanding Spark Architecture: How It All Comes Together"})})})," ",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(s.a,{href:"https://medium.com/@amitjoshi7/spark-architecture-a-deep-dive-2480ef45f0be",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Spark Architecture: A Deep Dive"})})})," ",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(s.a,{href:"https://spark.apache.org/docs/latest/cluster-overview.html",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Cluster Mode Overview"})})})," ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsx)(s.p,{children:"At its core, Spark is a distributed processing framework designed to handle large datasets across multiple machines (or nodes). Spark\u2019s key strength lies in its speed \u2014 it processes data up to 100 times faster than traditional systems like Hadoop MapReduce by storing intermediate data in memory and processing tasks in parallel."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"The Apache Spark framework uses a master-slave architecture that consists of a driver, which runs as a master node, and many executors that run across as worker nodes in the cluster. Apache Spark can be used for batch processing and real-time processing as well."})}),"\n",(0,t.jsx)(s.p,{children:"Spark divides large datasets into smaller pieces and processes them simultaneously across multiple machines, ensuring fast, scalable data processing."}),"\n",(0,t.jsx)("img",{src:"/img/streams/spark/01-spark-architecture.png",alt:"01-spark-architecture.png"}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(s.h3,{id:"the-spark-driver-master",children:"The Spark Driver (Master)"}),"\n",(0,t.jsx)(s.p,{children:"The driver is the program or process responsible for coordinating the execution of the Spark application. It runs the main function and creates the SparkContext, which connects to the cluster manager."}),"\n",(0,t.jsx)(s.p,{children:"It manages job scheduling and converts your code into tasks, assigns them to Executors, and monitors progress. Once tasks are completed, the Driver collects the results from each task, assembling the final answer. It\u2019s like the project manager overseeing everything."}),"\n",(0,t.jsx)(s.h3,{id:"sparkcontext",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"sparkContext"})})}),"\n",(0,t.jsx)(s.p,{children:"SparkContext is the entry point for any Spark functionality. It represents the connection to a Spark cluster and can be used to create RDDs (Resilient Distributed Datasets), accumulators, and broadcast variables. SparkContext also coordinates the execution of tasks."}),"\n",(0,t.jsx)(s.h3,{id:"the-spark-executors-slaves",children:"The Spark Executors (Slaves)"}),"\n",(0,t.jsx)(s.p,{children:"These are the workers who process data. They are launched on worker nodes and communicate with the driver program and cluster manager. Executors run tasks concurrently and store data in memory or disk for caching and intermediate storage."}),"\n",(0,t.jsx)(s.h3,{id:"the-cluster-manager",children:"The Cluster Manager"}),"\n",(0,t.jsx)(s.p,{children:"The Cluster Manager is responsible for allocating resources and managing the cluster on which the Spark application runs. Spark supports various cluster managers like Apache Mesos, Hadoop YARN, and standalone cluster manager."}),"\n",(0,t.jsx)(s.p,{children:"Spark uses a Cluster Manager to allocate resources like CPU, memory, and storage. Think of the Cluster Manager as a traffic controller, ensuring that all the machines (nodes) in the cluster are effectively utilized. This ensures each application has the resources it needs to run efficiently. Spark supports 3 types of cluster managers:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://spark.apache.org/docs/latest/spark-standalone.html",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Standalone Mode"})})}),": Spark\u2019s built-in cluster-manager, is ideal for small to medium clusters. (easy to set up)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://spark.apache.org/docs/latest/running-on-yarn.html",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Hadoop YARN"})})})," (Yet Another Resource Negotiator): Common in Hadoop environments. It manages resources across multiple applications running on a Hadoop cluster."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://spark.apache.org/docs/latest/running-on-kubernetes.html",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Kubernetes"})})}),": Popular for dynamic and cloud-based, containerized workloads."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://spark.apache.org/docs/latest/running-on-mesos.html",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Apache Mesos"})})}),": A general cluster manager that can also run Hadoop MapReduce and service applications. (",(0,t.jsx)(s.strong,{children:"Deprecated"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"task",children:"Task"}),"\n",(0,t.jsx)(s.p,{children:"A task is the smallest unit of work in Spark, representing a unit of computation that can be performed on a single partition of data. The driver program divides the Spark job into tasks and assigns them to the executor nodes for execution."}),"\n",(0,t.jsx)(s.h3,{id:"rdd-resilient-distributed-datasets",children:"RDD (Resilient Distributed Datasets)"}),"\n",(0,t.jsx)(s.p,{children:"RDDs are the fundamental data structures in Spark. They are immutable, distributed collections of objects that can be processed in parallel. RDDs provide fault tolerance by tracking the lineage of transformations to recompute lost data."}),"\n",(0,t.jsx)(s.p,{children:"RDD includes all sorts of Python, Scala, or Java objects for users to use."}),"\n",(0,t.jsx)("img",{src:"/img/streams/spark/02-rdd-diagram.png",alt:"02-rdd-diagram.png"}),"\n",(0,t.jsx)(s.p,{children:"Each dataset in RDD is divided into logical partitions. These partitions are stored and processed on various machines of a cluster."}),"\n",(0,t.jsx)(s.h3,{id:"dag-directed-acyclic-graph",children:"DAG (Directed Acyclic Graph)"}),"\n",(0,t.jsx)(s.p,{children:"A DAG represents a series of transformations on data. Spark optimizes the execution plan by constructing a DAG of stages. This graph helps in efficient pipelining of operations and task scheduling."}),"\n",(0,t.jsx)(s.p,{children:"The DAG in Spark/PySpark is a fundamental concept that plays a crucial role in the Spark execution model. The DAG is \u201cdirected\u201d because the operations are executed in a specific order, and \u201cacyclic\u201d because there are no loops or cycles in the execution plan. This means that each stage depends on the completion of the previous stage, and each task within a stage can run independently of the other."}),"\n",(0,t.jsx)("img",{src:"/img/streams/spark/03-dag-visualisation.png",alt:"03-dag-visualisation.png"}),"\n",(0,t.jsx)(s.p,{children:"At a high level, a DAG represents the logical execution plan of a Spark job. When a Spark application is submitted, Spark translates the high-level operations (such as transformations and actions) specified in the application code into a DAG of stages and tasks."}),"\n",(0,t.jsx)(s.h3,{id:"dag-scheduler",children:"DAG Scheduler"}),"\n",(0,t.jsx)(s.p,{children:"The DAG Scheduler divides the operator graph into stages and submits them to the Task Scheduler. It optimizes the execution plan by rearranging and combining operations where possible, grouping them into stages, and sending these stages to the Task Scheduler."}),"\n",(0,t.jsx)("img",{src:"/img/streams/spark/04-dag-scheduler.png",alt:"04-dag-scheduler.png"}),"\n",(0,t.jsx)(s.h3,{id:"task-scheduler",children:"Task Scheduler"}),"\n",(0,t.jsx)(s.p,{children:"The Task Scheduler launches tasks via the cluster manager. It sends tasks to the executor nodes, ensuring parallel execution across the cluster. Tasks for each stage are launched according to the number of partitions."}),"\n",(0,t.jsx)(s.h2,{id:"built-in-libraries",children:"Built-in Libraries"}),"\n",(0,t.jsx)(s.p,{children:"Apache Spark comes with a rich set of built-in libraries that cater to various data processing needs:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://spark.apache.org/sql/?ref=chaosgenius.io",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Spark SQL"})})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://spark.apache.org/mllib/?ref=chaosgenius.io",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Spark MLlib"})})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://spark.apache.org/graphx/?ref=chaosgenius.io",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Spark GraphX"})})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://spark.apache.org/docs/latest/streaming-programming-guide.html?ref=chaosgenius.io",children:(0,t.jsx)(s.em,{children:(0,t.jsx)(s.strong,{children:"Spark Streaming"})})})}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>i,x:()=>c});var a=r(6540);const t={},n=a.createContext(t);function i(e){const s=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(n.Provider,{value:s},e.children)}}}]);