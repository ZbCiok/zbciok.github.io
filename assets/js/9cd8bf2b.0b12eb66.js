"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[9079],{2287:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"streams/kafka-streams/index","title":"Kafka Streams","description":"Kafka Streams","source":"@site/docs/streams/kafka-streams/index.mdx","sourceDirName":"streams/kafka-streams","slug":"/kafka-streams","permalink":"/docs/kafka-streams","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"slug":"/kafka-streams"},"sidebar":"tutorialSidebar","previous":{"title":"Examples","permalink":"/docs/streams/java-8-streams/examples"},"next":{"title":"Glossary","permalink":"/docs/streams/kafka-streams/glossary"}}');var r=a(4848),n=a(8453),i=a(7170),o=a(3304);const l={slug:"/kafka-streams"},c="Kafka Streams",d={},h=[{value:"<em><strong>... for Confluent Platform</strong></em>",id:"-for-confluent-platform",level:2},{value:"Stream",id:"stream",level:2},{value:"Stream Processing Application",id:"stream-processing-application",level:2},{value:"Processor Topology",id:"processor-topology",level:2},{value:"Stream Processor",id:"stream-processor",level:2},{value:"Stateful Stream Processing",id:"stateful-stream-processing",level:2},{value:"Duality of Streams and Tables",id:"duality-of-streams-and-tables",level:2},{value:"KStream",id:"kstream",level:2},{value:"KTable",id:"ktable",level:2},{value:"Effect of Kafka log compaction",id:"effect-of-kafka-log-compaction",level:2},{value:"GlobalKTable",id:"globalktable",level:2},{value:"Time",id:"time",level:2},{value:"event-time",id:"event-time",level:3},{value:"processing-time",id:"processing-time",level:3},{value:"ingestion-time",id:"ingestion-time",level:3},{value:"stream-time",id:"stream-time",level:3},{value:"Timestamps",id:"timestamps",level:3},{value:"Assign timestamps to output records with the Processor API",id:"assign-timestamps-to-output-records-with-the-processor-api",level:4},{value:"Assign timestamps to output records with the Kafka Streams API",id:"assign-timestamps-to-output-records-with-the-kafka-streams-api",level:4},{value:"Aggregations",id:"aggregations",level:2},{value:"Joins",id:"joins",level:2},{value:"Windowing",id:"windowing",level:2},{value:"Interactive Queries",id:"interactive-queries",level:2}];function m(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"kafka-streams",children:"Kafka Streams"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://kafka.apache.org/0102/documentation/streams/",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Kafka Streams"})})}),(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.a,{href:"https://kafka.apache.org/20/documentation/streams/developer-guide/",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Developer Guide for Kafka Streams"})})})]}),"\n",(0,r.jsx)(t.h2,{id:"-for-confluent-platform",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"... for Confluent Platform"})})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/concepts.html",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Kafka Streams Basics for Confluent"})})})}),"\n",(0,r.jsxs)(t.p,{children:["In this section we summarize the key concepts of Kafka Streams. For more detailed information refer to ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/architecture.html#streams-architecture",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Kafka Streams Architecture for Confluent Platform"})})})," and the Kafka Streams Developer Guide for Confluent Platform. You may also be interested in the ",(0,r.jsx)(t.a,{href:"https://developer.confluent.io/learn-kafka/kafka-streams/?session_ref=https://www.google.com/&_gl=1*12nf27f*_gcl_au*MTYyNDM0OTAxNS4xNzMwMTIwNTQ0LjE5NDczMDA3NDguMTczMzg2MTk0NS4xNzMzODYxOTQ1*_ga*NTE5ODY0NDI3LjE3MzAxMjA1NDQ.*_ga_D2D3EGKSGD*MTczNDQzNDgzNy42MC4xLjE3MzQ0NDAzMjMuNTguMC4w&_ga=2.223317534.484256090.1734434838-519864427.1730120544",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Kafka Streams 101"})})})," course."]}),"\n",(0,r.jsx)(t.h2,{id:"stream",children:"Stream"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"stream"})," is the most important abstraction provided by Kafka Streams: it represents an unbounded, continuously updating data set, where unbounded means \u201cof unknown or of unlimited size\u201d. Just like a topic in Kafka, a stream in the Kafka Streams API consists of one or more stream partitions."]}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"stream partition"})," is an, ordered, replayable, and fault-tolerant sequence of immutable data records, where a data record is defined as a key-value pair."]}),"\n",(0,r.jsx)(t.h2,{id:"stream-processing-application",children:"Stream Processing Application"}),"\n",(0,r.jsx)(t.p,{children:"A stream processing application is any program that makes use of the Kafka Streams library. In practice, this means it is probably \u201cyour\u201d application. It may define its computational logic through one or more processor topologies."}),"\n",(0,r.jsx)(t.p,{children:"Your stream processing application doesn\u2019t run inside a broker. Instead, it runs in a separate JVM instance, or in a separate cluster entirely."}),"\n",(0,r.jsxs)(t.p,{children:["An ",(0,r.jsx)(t.strong,{children:"application instance"})," is any running instance or \u201ccopy\u201d of your application. Application instances are the primary means to elasticly scale and parallelize your application, and they also contribute to making it fault-tolerant. For example, you may need the power of ten machines to handle the incoming data load of your application; here, you could opt to run ten instances of your application, one on each machine, and these instances would automatically collaborate on the data processing \u2013 even as new instances/machines are added or existing ones removed during live operation."]}),"\n",(0,r.jsx)(t.h2,{id:"processor-topology",children:"Processor Topology"}),"\n",(0,r.jsx)(t.p,{children:"A processor topology or simply topology defines the computational logic of the data processing that needs to be performed by a stream processing application. A topology is a graph of stream processors (nodes) that are connected by streams (edges). Developers can define topologies either via the low-level Processor API or via the Kafka Streams DSL, which builds on top of the former."}),"\n",(0,r.jsx)("img",{src:"/img/streams/kafka-streams/kafka-streams-processor-topology-01.png",alt:"kafka-streams-processor-topology-01.png"}),"\n",(0,r.jsx)(t.h2,{id:"stream-processor",children:"Stream Processor"}),"\n",(0,r.jsx)(t.p,{children:"A stream processor is a node in the processor topology as shown in the diagram of section Processor Topology. It represents a processing step in a topology, i.e. it is used to transform data. Standard operations such as map or filter, joins, and aggregations are examples of stream processors that are available in Kafka Streams out of the box. A stream processor receives one input record at a time from its upstream processors in the topology, applies its operation to it, and may subsequently produce one or more output records to its downstream processors."}),"\n",(0,r.jsx)(t.p,{children:"Kafka Streams provides two APIs to define stream processors:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"declarative, functional DSL"})})})," is the recommended API for most users \u2013 and notably for starters \u2013 because most data processing use cases can be expressed in just a few lines of DSL code. Here, you typically use built-in operations such as map and filter."]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/processor-api.html#streams-developer-guide-processor-api",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"imperative, lower-level Processor API"})})})," provides you with even more flexibility than the DSL but at the expense of requiring more manual coding work. Here, you can define and connect custom processors as well as directly interact with ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/architecture.html#streams-architecture-state",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"state stores"})})}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"stateful-stream-processing",children:"Stateful Stream Processing"}),"\n",(0,r.jsx)(t.p,{children:"Some stream processing applications don\u2019t require state \u2013 they are stateless \u2013 which means the processing of a message is independent from the processing of other messages. Examples are when you only need to transform one message at a time, or filter out messages based on some condition."}),"\n",(0,r.jsx)(t.p,{children:"In practice, however, most applications require state \u2013 they are stateful \u2013 in order to work correctly, and this state must be managed in a fault-tolerant manner. Your application is stateful whenever, for example, it needs to join, aggregate, or window its input data. Kafka Streams provides your application with powerful, elastic, highly scalable, and fault-tolerant stateful processing capabilities."}),"\n",(0,r.jsx)(t.h2,{id:"duality-of-streams-and-tables",children:"Duality of Streams and Tables"}),"\n",(0,r.jsx)(t.p,{children:"When implementing stream processing use cases in practice, you typically need both streams and also databases. An example use case that is very common in practice is an e-commerce application that enriches an incoming stream of customer transactions with the latest customer information from a database table. In other words, streams are everywhere, but databases are everywhere, too."}),"\n",(0,r.jsx)(t.p,{children:"Any stream processing technology must therefore provide first-class support for streams and tables. Kafka\u2019s Streams API provides such functionality through its core abstractions for streams and tables, which we will talk about in a minute. Now, an interesting observation is that there is actually a close relationship between streams and tables, the so-called stream-table duality. And Kafka exploits this duality in many ways: for example, to make your applications elastic, to support fault-tolerant stateful processing, or to run Kafka Streams Interactive Queries for Confluent Platform against your application\u2019s latest processing results. And, beyond its internal usage, the Kafka Streams API also allows developers to exploit this duality in their own applications."}),"\n",(0,r.jsx)(t.p,{children:"Before we discuss concepts such as aggregations in Kafka Streams we must first introduce tables in more detail, and talk about the aforementioned stream-table duality. Essentially, this duality means that a stream can be viewed as a table, and a table can be viewed as a stream."}),"\n",(0,r.jsx)(t.p,{children:"The following explanations are kept simple intentionally and skip the discussion of compound keys, multisets, and so on."}),"\n",(0,r.jsx)(t.p,{children:"A simple form of a table is a collection of key-value pairs, also called a map or associative array. Such a table may look as follows:"}),"\n",(0,r.jsx)("img",{src:"/img/streams/kafka-streams/kafka-streams-a-table-01.png",alt:"kafka-streams-a-table-01.png"}),"\n",(0,r.jsx)(t.p,{children:"The stream-table duality describes the close relationship between streams and tables."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Stream as Table:"})," A stream can be considered a changelog of a table, where each data record in the stream captures a state change of the table. A stream is thus a table in disguise, and it can be easily turned into a \u201creal\u201d table by replaying the changelog from beginning to end to reconstruct the table. Similarly, aggregating data records in a stream will return a table. For example, we could compute the total number of pageviews by user from an input stream of pageview events, and the result would be a table, with the table key being the user and the value being the corresponding pageview count."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Table as Stream:"})," A table can be considered a snapshot, at a point in time, of the latest value for each key in a stream (a stream\u2019s data records are key-value pairs). A table is thus a stream in disguise, and it can be easily turned into a \u201creal\u201d stream by iterating over each key-value entry in the table."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Let\u2019s illustrate this with an example. Imagine a table that tracks the total number of pageviews by user (first column of diagram below). Over time, whenever a new pageview event is processed, the state of the table is updated accordingly. Here, the state changes between different points in time \u2013 and different revisions of the table \u2013 can be represented as a changelog stream (second column)."}),"\n",(0,r.jsx)("img",{src:"/img/streams/kafka-streams/kafka-streams-talbe-stream-01.png",alt:"kafka-streams-talbe-stream-01.png"}),"\n",(0,r.jsx)(t.p,{children:"Because of the stream-table duality, the same stream can be used to reconstruct the original table (third column):"}),"\n",(0,r.jsx)("img",{src:"/img/streams/kafka-streams/kafka-streams-streams-table-01.png",alt:"kafka-streams-streams-table-01.png"}),"\n",(0,r.jsx)(t.p,{children:"The same mechanism is used, for example, to replicate databases via change data capture (CDC) and, within Kafka Streams, to replicate its so-called state stores across machines for fault tolerance. The stream-table duality is such an important concept for stream processing applications in practice that Kafka Streams models it explicitly via the KStream and KTable abstractions, which we describe in the next sections."}),"\n",(0,r.jsx)(t.h2,{id:"kstream",children:"KStream"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"KStream"})," is an abstraction of a record stream, where each data record represents a self-contained datum in the unbounded data set. Using the table analogy, data records in a record stream are always interpreted as an \u201cINSERT\u201d \u2013 think: adding more entries to an append-only ledger \u2013 because no record replaces an existing row with the same key. Examples are a credit card transaction, a page view event, or a server log entry."]}),"\n",(0,r.jsx)(t.p,{children:"Only the Kafka Streams DSL has the notion of a KStream."}),"\n",(0,r.jsx)(t.p,{children:"To illustrate, imagine the following two data records are being sent to the stream:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'("alice", 1) --\x3e ("alice", 3)\n'})}),"\n",(0,r.jsx)(t.p,{children:"If your stream processing application were to sum the values per user, it would return 4 for alice. Why? Because the second data record would not be considered an update of the previous record. Compare this behavior of KStream to KTable below, which would return 3 for alice."}),"\n",(0,r.jsx)(t.h2,{id:"ktable",children:"KTable"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"KTable"})," is an abstraction of a changelog stream, where each data record represents an update. More precisely, the value in a data record is interpreted as an \u201cUPDATE\u201d of the last value for the same record key, if any (if a corresponding key doesn\u2019t exist yet, the update will be considered an INSERT). Using the table analogy, a data record in a changelog stream is interpreted as an UPSERT aka INSERT/UPDATE because any existing row with the same key is overwritten. Also, null values are interpreted in a special way: a record with a null value represents a \u201cDELETE\u201d or tombstone for the record\u2019s key."]}),"\n",(0,r.jsx)(t.p,{children:"Only the Kafka Streams DSL has the notion of a KTable."}),"\n",(0,r.jsx)(t.p,{children:"To illustrate, let\u2019s imagine the following two data records are being sent to the stream:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'("alice", 1) --\x3e ("alice", 3)\n'})}),"\n",(0,r.jsx)(t.p,{children:"If your stream processing application were to sum the values per user, it would return 3 for alice. Why? Because the second data record would be considered an update of the previous record. Compare this behavior of KTable with the illustration for KStream above, which would return 4 for alice."}),"\n",(0,r.jsx)(t.p,{children:"You have already seen an example of a changelog stream in the section Duality of Streams and Tables. Another example are change data capture (CDC) records in the changelog of a relational database, representing which row in a database table was inserted, updated, or deleted."}),"\n",(0,r.jsx)(t.p,{children:"KTable also provides an ability to look up current values of data records by keys. This table-lookup functionality is available through join operations (see also Joining in the Developer Guide) as well as through Interactive Queries."}),"\n",(0,r.jsx)(t.h2,{id:"effect-of-kafka-log-compaction",children:"Effect of Kafka log compaction"}),"\n",(0,r.jsx)(t.p,{children:"Another way of thinking about KStream and KTable is as follows: If you were to store a KTable into a Kafka topic, you\u2019d probably want to enable Kafka\u2019s log compaction feature to save storage space."}),"\n",(0,r.jsxs)(t.p,{children:["But it wouldn\u2019t be safe to enable log compaction in the case of a KStream, because as soon as ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/kafka/design/log_compaction.html",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"log compaction"})})}),' begins purging older data records of the same key, it would break the semantics of the data. To pick up the illustration example again, you\u2019d suddenly get a 3 for alice, instead of a 4, because log compaction would have removed the ("alice", 1) data record. this means that log compaction is safe for a KTable (changelog stream) but it is a mistake for a KStream (record stream).']}),"\n",(0,r.jsx)(t.h2,{id:"globalktable",children:"GlobalKTable"}),"\n",(0,r.jsx)(t.p,{children:"Like a KTable, a GlobalKTable is an abstraction of a changelog stream, where each data record represents an update."}),"\n",(0,r.jsx)(t.p,{children:"Only the Kafka Streams DSL has the notion of a GlobalKTable."}),"\n",(0,r.jsx)(t.p,{children:"A GlobalKTable differs from a KTable in the data that they are being populated with, i.e. which data from the underlying Kafka topic is being read into the respective table. Slightly simplified, imagine you have an input topic with 5 partitions. In your application, you want to read this topic into a table. Also, you want to run your application across 5 application instances for maximum parallelism."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["If you read the input topic into a ",(0,r.jsx)(t.strong,{children:"KTable"}),", then the \u201clocal\u201d KTable instance of each application instance will be populated with data ",(0,r.jsx)(t.strong,{children:"from only 1 partition"})," of the topic\u2019s 5 partitions."]}),"\n",(0,r.jsxs)(t.li,{children:["If you read the input topic into a ",(0,r.jsx)(t.strong,{children:"GlobalKTable"}),", then the local GlobalKTable instance of each application instance will be populated with data ",(0,r.jsx)(t.strong,{children:"from all partitions of the topic"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"GlobalKTable provides the ability to look up current values of data records by keys. This table-lookup functionality is available through join operations (as described in Joining in the Developer Guide) and Kafka Streams Interactive Queries for Confluent Platform."}),"\n",(0,r.jsx)(t.p,{children:"Benefits of global tables:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"You can use global tables to \u201cbroadcast\u201d information to all running instances of your application."}),"\n",(0,r.jsxs)(t.li,{children:["Global tables enable more convenient and efficient joins.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Global tables enable star joins."}),"\n",(0,r.jsx)(t.li,{children:"Global tables are more efficient when chaining multiple joins."}),"\n",(0,r.jsx)(t.li,{children:"When joining against a global table, the input data doesn\u2019t need to be co-partitioned."}),"\n",(0,r.jsx)(t.li,{children:"Global tables support \u201cforeign-key\u201d lookups, which means that you can look up data in the table not just by record key, but also by data in the record values. In this case, the join always uses the table\u2019s primary key, and the \u201cforeign key\u201d refers to the stream records. Unlike a stream-table join that always calculates the join based on the stream-record key, a stream-globalKTable join enables you to extract the join key directly from the stream record\u2019s value."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Drawbacks of global tables include:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Increased local storage consumption compared to the (partitioned) KTable, because the entire topic is tracked."}),"\n",(0,r.jsx)(t.li,{children:"Increased network and Kafka broker load compared to the (partitioned) KTable, because the entire topic is read."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"time",children:"Time"}),"\n",(0,r.jsx)(t.p,{children:"A critical aspect in stream processing is the notion of time, and how it is modeled and integrated. For example, some operations such as Windowing are defined based on time boundaries."}),"\n",(0,r.jsx)(t.p,{children:"Kafka Streams supports the following notions of time:"}),"\n",(0,r.jsx)(t.h3,{id:"event-time",children:"event-time"}),"\n",(0,r.jsx)(t.p,{children:"The point in time when an event or data record occurred (that is, was originally created by the source). Achieving event-time semantics typically requires embedding timestamps in the data records at the time a data record is being produced."}),"\n",(0,r.jsx)(t.h3,{id:"processing-time",children:"processing-time"}),"\n",(0,r.jsx)(t.p,{children:"The point in time when the event or data record happens to be processed by the stream processing application (that is, when the record is being consumed). The processing-time may be milliseconds, hours, days, etc. later than the original event-time."}),"\n",(0,r.jsx)(t.h3,{id:"ingestion-time",children:"ingestion-time"}),"\n",(0,r.jsx)(t.p,{children:"The point in time when an event or data record is stored in a topic partition by a Kafka broker. Ingestion-time is similar to event-time, as a timestamp gets embedded in the data record itself. The difference is that the timestamp is generated when the record is appended to the target topic by the Kafka broker, not when the record is created at the source. Ingestion-time may approximate event-time reasonably well if we assume that the time difference between creation of the record and its ingestion into Kafka is sufficiently small, where \u201csufficiently\u201d depends on the specific use case. Thus, ingestion-time may be a reasonable alternative for use cases where event-time semantics are not possible, perhaps because the data producers don\u2019t embed timestamps (such as with older versions of Kafka\u2019s Java producer client) or the producer cannot assign timestamps directly (for example, does not have access to a local clock)."}),"\n",(0,r.jsx)(t.h3,{id:"stream-time",children:"stream-time"}),"\n",(0,r.jsx)(t.p,{children:"The maximum timestamp seen over all processed records so far. Kafka Streams tracks stream-time on a per-task basis."}),"\n",(0,r.jsx)(t.h3,{id:"timestamps",children:"Timestamps"}),"\n",(0,r.jsxs)(t.p,{children:["Kafka Streams assigns a ",(0,r.jsx)(t.strong,{children:"timestamp"})," to every data record via so-called timestamp extractors. These per-record timestamps describe the progress of a stream with regards to time (although records may be out-of-order within the stream) and are leveraged by time-dependent operations such as joins. We call it the ",(0,r.jsx)(t.strong,{children:"event-time"})," of the application to differentiate with the wall-clock-time when this application is actually executing. Event-time is also used to synchronize multiple input streams within the same application."]}),"\n",(0,r.jsx)(t.p,{children:"Concrete implementations of timestamp extractors may retrieve or compute timestamps based on the actual contents of data records such as an embedded timestamp field to provide event-time or ingestion-time semantics, or use any other approach such as returning the current wall-clock time at the time of processing, thereby yielding processing-time semantics to stream processing applications. Developers can thus enforce different notions/semantics of time depending on their business needs."}),"\n",(0,r.jsx)(t.p,{children:"Finally, whenever a Kafka Streams application writes records to Kafka, then it will also assign timestamps to these new records. The way the timestamps are assigned depends on the context:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"When new output records are generated via directly processing some input record, output record timestamps are inherited from input record timestamps directly."}),"\n",(0,r.jsx)(t.li,{children:"When new output records are generated via periodic functions, the output record timestamp is defined as the current internal time of the stream task."}),"\n",(0,r.jsx)(t.li,{children:"For aggregations, the timestamp of the resulting update record will be that of the latest input record that triggered the update."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"For aggregations and joins, timestamps are computed using the following rules."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"For joins (stream-stream, table-table) that have left and right input records, the timestamp of the output record is assigned max(left.ts, right.ts)."}),"\n",(0,r.jsx)(t.li,{children:"For stream-table joins, the output record is assigned the timestamp from the stream record."}),"\n",(0,r.jsx)(t.li,{children:"For aggregations, Kafka Streams also computes the max timestamp across all records, per key, either globally (for non-windowed) or per-window."}),"\n",(0,r.jsx)(t.li,{children:"Stateless operations are assigned the timestamp of the input record. For flatMap and siblings that emit multiple records, all output records inherit the timestamp from the corresponding input record."}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"assign-timestamps-to-output-records-with-the-processor-api",children:"Assign timestamps to output records with the Processor API"}),"\n",(0,r.jsx)(t.p,{children:"You can change the default behavior in the Processor API by assigning timestamps to output records explicitly when calling #forward()."}),"\n",(0,r.jsx)(t.p,{children:"The forward() method takes two parameters: a key-value pair and a timestamp. The optional timestamp parameter can be used to set the timestamp of the output record explicitly."}),"\n",(0,r.jsx)(t.p,{children:"The following example shows the explicit assignment of timestamps to output records using the forward() method."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public class MyProcessor implements Processor<String, String> {\n  private ProcessorContext context;\n\n  @Override\n  public void init(ProcessorContext context) {\n    this.context = context;\n  }\n\n  @Override\n  public void process(String key, String value) {\n    // Extract the timestamp from the input record.\n    long inputTimestamp = context.timestamp();\n\n    // Process the input record.\n    String outputValue = processRecord(value);\n\n    // Assign the timestamp to the output record explicitly.\n    // You implement the computeOutputTimestamp method for your use case.\n    long outputTimestamp = computeOutputTimestamp(inputTimestamp);\n    KeyValue<String, String> outputRecord = KeyValue.pair(key, outputValue);\n    context.forward(outputRecord, outputTimestamp);\n  }\n\n  @Override\n  public void close() {}\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"In this example, the timestamp is extracted from the input record by using the context.timestamp() method. The computeOutputTimestamp() custom method, which you implement, computes the timestamp for the output record. Finally, a new key-value pair is created for the output record by using KeyValue.pair() and calling context.forward() with this pair and the computed timestamp."}),"\n",(0,r.jsx)(t.h4,{id:"assign-timestamps-to-output-records-with-the-kafka-streams-api",children:"Assign timestamps to output records with the Kafka Streams API"}),"\n",(0,r.jsx)(t.p,{children:"You can assign timestamps to output records explicitly in Kafka Streams by using the TimestampExtractor interface. Implement this interface to extract a timestamp from each record and use it for processing-time or event-time semantics."}),"\n",(0,r.jsx)(t.p,{children:"The following example shows the explicit assignment of timestamps to output records using the TimestampExtractor interface."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'public class CustomTimestampExtractor implements TimestampExtractor {\n    @Override\n    public long extract(ConsumerRecord<Object, Object> record, long previousTimestamp) {\n        // Extract timestamp from record\n        long timestamp = ...;\n        return timestamp;\n    }\n}\n\n// Use the custom timestamp extractor\nKStream<String, String> stream = builder.stream("input-topic", Consumed.with(Serdes.String(), Serdes.String())\n        .withTimestampExtractor(new CustomTimestampExtractor()));\n\n// Process records with timestamps\nstream.map((key, value) -> new KeyValue<>(key, value.toUpperCase()))\n        .to("output-topic", Produced.with(Serdes.String(), Serdes.String()));\n'})}),"\n",(0,r.jsx)(t.p,{children:"In this example, a custom TimestampExtractor extracts a timestamp from each record and returns it as a long value. The custom extractor is used when creating a KStream by calling the withTimestampExtractor() method on the Consumed object."}),"\n",(0,r.jsx)(t.p,{children:"Once you have a stream with timestamps, you can process records with processing-time or event-time semantics by using methods like windowedBy() or groupByKey()."}),"\n",(0,r.jsx)(t.h2,{id:"aggregations",children:"Aggregations"}),"\n",(0,r.jsxs)(t.p,{children:["An ",(0,r.jsx)(t.strong,{children:"aggregation"})," operation takes one input stream or table, and yields a new table by combining multiple input records into a single output record. Examples of aggregations are computing counts or sum."]}),"\n",(0,r.jsxs)(t.p,{children:["In the ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Kafka Streams DSL"})})}),", an input stream of an ",(0,r.jsx)(t.strong,{children:"aggregation"})," operation can be a KStream or a KTable, but the output stream will always be a KTable. This allows Kafka Streams to update an aggregate value upon the out-of-order arrival of further records after the value was produced and emitted. When such out-of-order arrival happens, the aggregating KStream or KTable emits a new aggregate value. Because the output is a KTable, the new value is considered to overwrite the old value with the same key in subsequent processing steps. For more information on out-of-order records, see ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/concepts.html#streams-concepts-out-out-order-handling",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Out-of-Order Handling"})})}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"joins",children:"Joins"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"join"})," operation merges two input streams and/or tables based on the keys of their data records, and yields a new stream/table."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl-joins",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"join operations"})})})," available in the ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Kafka Streams DSL"})})})," differ based on which kinds of streams and tables are being joined; for example, KStream-KStream joins versus KStream-KTable joins."]}),"\n",(0,r.jsx)(t.h2,{id:"windowing",children:"Windowing"}),"\n",(0,r.jsx)(t.p,{children:"Windowing lets you control how to group records that have the same key for stateful operations such as aggregations or joins into so-called windows. Windows are tracked per record key."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl-windowing",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Windowing operations"})})})," are available in the Kafka Streams DSL. When working with windows, you can specify a ",(0,r.jsx)(t.strong,{children:"grace period"})," for the window that indicates when window results are final. This grace period controls how long Kafka Streams will wait for out-of-order data records for a window. If a record arrives after the grace period of a window has passed (i.e., record.ts > window-end-time + grace-period), the record is discarded and will not be processed in that window."]}),"\n",(0,r.jsxs)(t.p,{children:["Out-of-order records are always possible in the real world and your applications must account for them properly. The system\u2019s time semantics determine how ",(0,r.jsx)(t.strong,{children:"out-of-order"})," records are handled. For processing-time, the semantics are \u201cwhen the record is being processed\u201d, which means that the notion of ",(0,r.jsx)(t.strong,{children:"out-of-order"})," records is not applicable. Similarly, for ingestion-time, the broker assigns timestamps in ascending order based on topic append order; the timestamp indicates ingestion-time only. Out-of-order records can only be considered for event-time semantics, where timestamps are set by producers specifically to indicate event-time. If two producers write to the same topic partition, there is no guarantee on the event append order."]}),"\n",(0,r.jsx)(t.p,{children:"Kafka Streams is able to properly handle out-of-order records for the relevant time semantics (event-time)."}),"\n",(0,r.jsx)(t.h2,{id:"interactive-queries",children:"Interactive Queries"}),"\n",(0,r.jsx)(t.p,{children:"Interactive Queries allow you to treat the stream processing layer as a lightweight embedded database, and to directly query the latest state of your stream processing application. You can do this without having to first materialize that state to external databases or external storage."}),"\n",(0,r.jsx)(t.p,{children:"Interactive Queries simplify the architecture and lead to more application-centric architectures."}),"\n",(0,r.jsx)(t.p,{children:"The following diagram juxtapose two architectures: the first does not use Interactive Queries whereas the second architecture does. It depends on the concrete use case to determine which of these architectures is a better fit \u2013 the important takeaway is that Kafka Streams and Interactive Queries give you the flexibility to pick and to compose the right one, rather than limiting you to just a single way."}),"\n",(0,r.jsx)(t.p,{children:"Here are some use case examples for applications that benefit from Interactive Queries:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Real-time monitoring: A front-end dashboard that provides threat intelligence (e.g., web servers currently under attack by cyber criminals) can directly query a Kafka Streams application that continuously generates the relevant information by processing network telemetry data in real-time."}),"\n",(0,r.jsx)(t.li,{children:"Video gaming: A Kafka Streams application continuously tracks location updates from players in the gaming universe. A mobile companion app can then directly query the Kafka Streams application to show the current location of a player to friends and family, and invite them to come along. Similarly, the game vendor can use the data to identify unusual hotspots of players, which may indicate a bug or an operational issue."}),"\n",(0,r.jsx)(t.li,{children:"Risk and fraud: A Kafka Streams application continuously analyzes user transactions for anomalies and suspicious behavior. An online banking application can directly query the Kafka Streams application when a user logs in to deny access to those users that have been flagged as suspicious."}),"\n",(0,r.jsx)(t.li,{children:"Trend detection: A Kafka Streams application continuously computes the latest top charts across music genres based on user listening behavior that is collected in real-time. Mobile or desktop applications of a music store can then interactively query for the latest charts while users are browsing the store."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["For more information, see the ",(0,r.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/streams/developer-guide/interactive-queries.html#streams-developer-guide-interactive-queries",children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"Developer Guide"})})}),"."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)("br",{}),"\n","\n",(0,r.jsx)(i.A,{items:(0,o.$S)().items})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},4365:(e,t,a)=>{a.d(t,{W:()=>c});var s=a(6540),r=a(502);const n=["zero","one","two","few","many","other"];function i(e){return n.filter((t=>e.includes(t)))}const o={locale:"en",pluralForms:i(["one","other"]),select:e=>1===e?"one":"other"};function l(){const{i18n:{currentLocale:e}}=(0,r.A)();return(0,s.useMemo)((()=>{try{return function(e){const t=new Intl.PluralRules(e);return{locale:e,pluralForms:i(t.resolvedOptions().pluralCategories),select:e=>t.select(e)}}(e)}catch(t){return console.error(`Failed to use Intl.PluralRules for locale "${e}".\nDocusaurus will fallback to the default (English) implementation.\nError: ${t.message}\n`),o}}),[e])}function c(){const e=l();return{selectMessage:(t,a)=>function(e,t,a){const s=e.split("|");if(1===s.length)return s[0];s.length>a.pluralForms.length&&console.error(`For locale=${a.locale}, a maximum of ${a.pluralForms.length} plural forms are expected (${a.pluralForms.join(",")}), but the message contains ${s.length}: ${e}`);const r=a.select(t),n=a.pluralForms.indexOf(r);return s[Math.min(n,s.length-1)]}(a,t,e)}}},7170:(e,t,a)=>{a.d(t,{A:()=>x});a(6540);var s=a(4164),r=a(7936),n=a(7634),i=a(4365),o=a(5242),l=a(9979),c=a(4861);const d={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var h=a(4848);function m(e){let{href:t,children:a}=e;return(0,h.jsx)(n.A,{href:t,className:(0,s.A)("card padding--lg",d.cardContainer),children:a})}function p(e){let{href:t,icon:a,title:r,description:n}=e;return(0,h.jsxs)(m,{href:t,children:[(0,h.jsxs)(c.A,{as:"h2",className:(0,s.A)("text--truncate",d.cardTitle),title:r,children:[a," ",r]}),n&&(0,h.jsx)("p",{className:(0,s.A)("text--truncate",d.cardDescription),title:n,children:n})]})}function u(e){let{item:t}=e;const a=(0,r.Nr)(t),s=function(){const{selectMessage:e}=(0,i.W)();return t=>e(t,(0,l.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:t}))}();return a?(0,h.jsx)(p,{href:a,icon:"\ud83d\uddc3\ufe0f",title:t.label,description:t.description??s(t.items.length)}):null}function f(e){let{item:t}=e;const a=(0,o.A)(t.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",s=(0,r.cC)(t.docId??void 0);return(0,h.jsx)(p,{href:t.href,icon:a,title:t.label,description:t.description??s?.description})}function g(e){let{item:t}=e;switch(t.type){case"link":return(0,h.jsx)(f,{item:t});case"category":return(0,h.jsx)(u,{item:t});default:throw new Error(`unknown item type ${JSON.stringify(t)}`)}}function b(e){let{className:t}=e;const a=(0,r.$S)();return(0,h.jsx)(x,{items:a.items,className:t})}function x(e){const{items:t,className:a}=e;if(!t)return(0,h.jsx)(b,{...e});const n=(0,r.d1)(t);return(0,h.jsx)("section",{className:(0,s.A)("row",a),children:n.map(((e,t)=>(0,h.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,h.jsx)(g,{item:e})},t)))})}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>o});var s=a(6540);const r={},n=s.createContext(r);function i(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);