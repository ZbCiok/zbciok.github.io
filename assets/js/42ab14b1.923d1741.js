"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[8352],{2143:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var s=a(4848),i=a(8453);const n={sidebar_position:120},r="Materialized Views",o={id:"streams/ksqlDB/materialized-views",title:"Materialized Views",description:"In any database, one of the main purposes of a table is to enable efficient queries over the data. ksqlDB stores events immutably in Apache Kafka\xae by using a simple key/value model. But how can queries be made efficient under this model? The answer is by leveraging materialized views.",source:"@site/docs/streams/ksqlDB/materialized-views.mdx",sourceDirName:"streams/ksqlDB",slug:"/streams/ksqlDB/materialized-views",permalink:"/docs/streams/ksqlDB/materialized-views",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:120,frontMatter:{sidebar_position:120},sidebar:"tutorialSidebar",previous:{title:"Confluent Platform",permalink:"/docs/streams/ksqlDB/confluent-platform"},next:{title:"Examples",permalink:"/docs/ksqlDB/examples"}},l={},c=[{value:"Stream/Table Duality",id:"streamtable-duality",level:2},{value:"Materialized Views",id:"materialized-views-1",level:2}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"materialized-views",children:"Materialized Views"})}),"\n",(0,s.jsx)(t.p,{children:"In any database, one of the main purposes of a table is to enable efficient queries over the data. ksqlDB stores events immutably in Apache Kafka\xae by using a simple key/value model. But how can queries be made efficient under this model? The answer is by leveraging materialized views."}),"\n",(0,s.jsx)(t.h2,{id:"streamtable-duality",children:"Stream/Table Duality"}),"\n",(0,s.jsx)(t.p,{children:"Streams and tables are closely related. A stream is a sequence of events that you can derive a table from. For example, a sequence of credit scores for a loan applicant can change over time. The sequence of credit scores is a stream. But this stream can be interpreted as a table to describe the applicant\u2019s current credit score."}),"\n",(0,s.jsxs)(t.p,{children:["Conversely, the table that represents current credit scores is really two things: the current credit scores, and also the sequence of changes to the credit scores for each applicant. This is a profound realization, and much has been written on this stream/table duality. For more information, see ",(0,s.jsx)(t.a,{href:"https://www.confluent.io/resources/streams-tables-two-sides-same-coin?session_ref=https://docs.ksqldb.io/en/latest/concepts/materialized-views/&_gl=1*mkc5yg*_gcl_au*MTYyNDM0OTAxNS4xNzMwMTIwNTQ0LjE5NDczMDA3NDguMTczMzg2MTk0NS4xNzMzODYxOTQ1*_ga*NTE5ODY0NDI3LjE3MzAxMjA1NDQ.*_ga_D2D3EGKSGD*MTczNDM0MDkyMC41Ny4xLjE3MzQzNDE3NTUuMzIuMC4w&_ga=2.115000847.928593428.1734333923-519864427.1730120544",children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"Streams and Tables: Two Sides of the Same Coin"})})}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Traditional databases have redo logs, but subscribing to changes can be cumbersome. Redo logs have much shorter retention than the Kafka changelog topic. A fully compacted Kafka changelog topic is the same as a database snapshot. Efficient queries evaluate just the changes."}),"\n",(0,s.jsx)(t.h2,{id:"materialized-views-1",children:"Materialized Views"}),"\n",(0,s.jsx)(t.p,{children:"The benefit of a materialized view is that it evaluates a query on the changes only (the delta), instead of evaluating the query on the entire table."}),"\n",(0,s.jsx)(t.p,{children:"When a new event is integrated, the current state of the view evolves into a new state. This transition happens by applying the aggregation function that defines the view with the current state and the new event. When a new event is integrated, the aggregation function that defines the view is applied only on this new event, leading to a new state for the view. In this way, a view is never \u201cfully recomputed\u201d when new events arrive. Instead, the view adjusts incrementally to account for the new information, which means that queries against materialized views are highly efficient."}),"\n",(0,s.jsx)(t.p,{children:"In ksqlDB, a table can be materialized into a view or not. If a table is created directly on top of a Kafka topic, it\u2019s not materialized. Non-materialized tables can\u2019t be queried, because they would be highly inefficient. On the other hand, if a table is derived from another collection, ksqlDB materializes its results, and you can make queries against it."}),"\n",(0,s.jsxs)(t.p,{children:["ksqlDB leverages the idea of stream/table duality by storing both components of each table. The current state of a table is stored locally and ephemerally on a specific server by using ",(0,s.jsx)(t.a,{href:"https://rocksdb.org/",children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"RocksDB"})})}),". The series of changes that are applied to a table is stored durably in a Kafka topic and is replicated across Kafka brokers. If a ksqlDB server with a materialization of a table fails, a new server rematerializes the table from the Kafka changelog."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var s=a(6540);const i={},n=s.createContext(i);function r(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);