"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[3536],{7360:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=s(4848),r=s(8453);const o={sidebar_position:20},n="Dictionary",i={id:"streams/kafka-streams/dictionary",title:"Dictionary",description:"SerDes (Data Types and Serialization)",source:"@site/docs/streams/kafka-streams/dictionary.mdx",sourceDirName:"streams/kafka-streams",slug:"/streams/kafka-streams/dictionary",permalink:"/docs/streams/kafka-streams/dictionary",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:20,frontMatter:{sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Kafka Streams",permalink:"/docs/kafka-streams"},next:{title:"Examples",permalink:"/docs/kafka-streams/examples"}},l={},c=[{value:"SerDes <em><strong>(Data Types and Serialization)</strong></em>",id:"serdes-data-types-and-serialization",level:2},{value:"Kafka Streams Topology",id:"kafka-streams-topology",level:2},{value:"Kafka Streams DSL",id:"kafka-streams-dsl",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"dictionary",children:"Dictionary"})}),"\n",(0,a.jsxs)(t.h2,{id:"serdes-data-types-and-serialization",children:["SerDes ",(0,a.jsx)(t.em,{children:(0,a.jsx)(t.strong,{children:"(Data Types and Serialization)"})})]}),"\n",(0,a.jsx)("img",{src:"/img/streams/kafka-streams/dictionary/serializer-deserializer-01.png",alt:"serializer-deserializer-01.png"}),"\n",(0,a.jsx)(t.p,{children:"Every Kafka Streams application must provide SerDes (Serializer/Deserializer) for the data types of record keys and record values (e.g. java.lang.String) to materialize the data when necessary. Operations that require such SerDes information include: stream(), table(), to(), through(), groupByKey(), groupBy()."}),"\n",(0,a.jsx)(t.p,{children:"You can provide SerDes by using either of these methods:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"By setting default SerDes in the java.util.Properties config instance."}),"\n",(0,a.jsx)(t.li,{children:"By specifying explicit SerDes when calling the appropriate API methods, thus overriding the defaults."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["...",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(t.em,{children:(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://kafka.apache.org/20/documentation/streams/developer-guide/datatypes",children:"https://kafka.apache.org/20/documentation/streams/developer-guide/datatypes"})})})]}),"\n",(0,a.jsx)(t.h2,{id:"kafka-streams-topology",children:"Kafka Streams Topology"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.strong,{children:"processor topology"})," or simply ",(0,a.jsx)(t.strong,{children:"topology"})," defines the stream processing computational logic for your application, i.e., how input data is transformed into output data. A topology is a graph of stream processors (nodes) that are connected by streams (edges) or shared state stores. There are two special processors in the topology:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Source Processor: A source processor is a special type of stream processor that does not have any upstream processors. It produces an input stream to its topology from one or multiple Kafka topics by consuming records from these topics and forward them to its down-stream processors."}),"\n",(0,a.jsx)(t.li,{children:"Sink Processor: A sink processor is a special type of stream processor that does not have down-stream processors. It sends any received records from its up-stream processors to a specified Kafka topic."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"A stream processing application \u2013 i.e., your application \u2013 may define one or more such topologies, though typically it defines only one. Developers can define topologies either via the low-level Processor API or via the Kafka Streams DSL, which builds on top of the former."}),"\n",(0,a.jsx)("img",{src:"/img/streams/kafka-streams/dictionary/topology-01.png",alt:"topology-01.png"}),"\n",(0,a.jsxs)(t.admonition,{title:"Example",type:"note",children:[(0,a.jsx)(t.p,{children:"The kafka streams topology is where we specify the logic:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:'final StreamsBuilder builder = new StreamsBuilder();\n\nKStream<String, String> views = builder.stream(\n        "input-topic",\n        Consumed.with(stringSerde, stringSerde)\n);\n\nKTable<String, Long> totalViews = views\n        .mapValues(v -> Long.parseLong(v))\n        .groupByKey(Grouped.with(stringSerde, longSerde))\n        .reduce(Long::sum);\n\ntotalViews.toStream().to("output-topic", Produced.with(stringSerde, longSerde));\n'})}),(0,a.jsx)(t.p,{children:"We are creating a KStream object called views to read data from the kafka topic input-topic. In this topic both the key and value are strings. Hence we use string serde for both the key and the value"}),(0,a.jsx)(t.p,{children:"Next we are created a KTable object with key as string and value as long. This is the object where we will store our computation result."}),(0,a.jsx)(t.p,{children:"We are using java lambda expressions to achieve the following"}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Convert the value to Long, since the value here is the video view count"}),"\n",(0,a.jsx)(t.li,{children:"Group all the same video titles together."}),"\n",(0,a.jsx)(t.li,{children:"For the Grouped video title, calculate the sum."}),"\n"]}),(0,a.jsx)(t.p,{children:"Finally the total video view count is written to a kafka topic called output-topic. In this topic, the key is a string and the value is a Long."})]}),"\n",(0,a.jsx)(t.p,{children:"Kafka Streams offers two ways to define the stream processing topology: the Kafka Streams DSL provides the most common data transformation operations such as map, filter, join and aggregations out of the box; the lower-level Processor API allows developers define and connect custom processors as well as to interact with state stores."}),"\n",(0,a.jsx)(t.p,{children:"A processor topology is merely a logical abstraction for your stream processing code. At runtime, the logical topology is instantiated and replicated inside the application for parallel processing (see Stream Partitions and Tasks for details)."}),"\n",(0,a.jsx)(t.h2,{id:"kafka-streams-dsl",children:"Kafka Streams DSL"}),"\n",(0,a.jsx)(t.p,{children:"Kafka Streams DSL (Domain-Specific Language) is a high-level, declarative language built on top of the core Kafka Streams library. It provides a simpler, more readable way to define common stream processing operations like filtering, mapping, aggregation, and windowing."}),"\n",(0,a.jsx)(t.p,{children:"Here\u2019s a basic example of using the Streams DSL to count the number of events per type"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:'// Starts building the stream processing topology.\nStreamsBuilder builder = new StreamsBuilder();\n// Reads events from the "event-stream" topic, with each event keyed // by a String and valued by an Event object.\nKStream<String, Event> events = builder.stream("event-stream");\n// Events are grouped by their type using event.getType(), and then // counted. This operation produces a KTable that continuously // updates as new events arrive.\nKTable<String, Long> eventCounts = events\n    .groupBy((key, event) -> event.getType())\n    .count();\n// Converts the KTable back to a KStream and writes the counts of each event type to the "event-counts-output" topic.\neventCounts.toStream().to("event-counts-output");\n'})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>i});var a=s(6540);const r={},o=a.createContext(r);function n(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);