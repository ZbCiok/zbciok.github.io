"use strict";(self.webpackChunkjreact_com_docsaurus_01=self.webpackChunkjreact_com_docsaurus_01||[]).push([[5753],{460:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>r});var t=a(4848),c=a(8453);const l={sidebar_position:1},i="Callbacks in Java",o={id:"streams/reactive-streams/callbacks-in-java",title:"Callbacks in Java",description:"Using synchronous and asynchronous callbacks in Java - including callbacks with lambda expressions, CompletableFuture, and more.",source:"@site/docs/streams/reactive-streams/callbacks-in-java.mdx",sourceDirName:"streams/reactive-streams",slug:"/streams/reactive-streams/callbacks-in-java",permalink:"/docs/streams/reactive-streams/callbacks-in-java",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Reactive Streams",permalink:"/docs/reactive-streams"},next:{title:"Asynchronicity",permalink:"/docs/streams/reactive-streams/asynchronicity"}},s={},r=[{value:"Anonymous inner class callback",id:"anonymous-inner-class-callback",level:3},{value:"Output",id:"output",level:4},{value:"Lambda callback",id:"lambda-callback",level:3},{value:"Asynchronous callbacks",id:"asynchronous-callbacks",level:3},{value:"Simple thread callback",id:"simple-thread-callback",level:3},{value:"Output",id:"output-1",level:4},{value:"Asynchronous parallel callback",id:"asynchronous-parallel-callback",level:3},{value:"Output",id:"output-2",level:4},{value:"CompletableFuture callback",id:"completablefuture-callback",level:3},{value:"Output",id:"output-3",level:4},{value:"Conclusion",id:"conclusion",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"callbacks-in-java",children:"Callbacks in Java"}),"\n",(0,t.jsx)(n.p,{children:"Using synchronous and asynchronous callbacks in Java - including callbacks with lambda expressions, CompletableFuture, and more."}),"\n",(0,t.jsx)(n.p,{children:"A callback operation in Java is one function that is passed to another function and executed after some action is completed.\nA callback can be executed either synchronously or asynchronously. In the case of a synchronous callback,\none function is executed right after another. In the case of an asynchronous callback, a function is executed after an undetermined period of time and happens in no particular sequence with other functions."}),"\n",(0,t.jsx)(n.h3,{id:"anonymous-inner-class-callback",children:"Anonymous inner class callback"}),"\n",(0,t.jsxs)(n.p,{children:["Anytime we pass an interface with a method implementation to another method in Java,\nwe are using the concept of a callback function. In the following code, we will pass the ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://docs.oracle.com/javase%2F8%2Fdocs%2Fapi%2F%2F/java/util/function/Consumer.html",children:"Consumer"})})})})," functional interface\nand an anonymous inner class (implementation without a name) to implement the accept() method."]}),"\n",(0,t.jsx)(n.p,{children:"Once the accept() method is implemented, we'll execute the action from the performAction method; then we'll execute the accept() method from the Consumer interface:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.function.Consumer;\n\npublic class AnonymousClassCallback {\n\n  public static void main(String[] args) {\n    performAction(new Consumer<String>() {\n      @Override\n      public void accept(String s) {\n        System.out.println(s);\n      }\n    });\n  }\n\n  public static void performAction(Consumer<String> consumer) {\n    System.out.println("Action is being performed...");\n    consumer.accept("Callback is executed");\n  }\n\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"output",children:"Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Action is being performed...\n\nCallback is executed...\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this code, we passed the Consumer interface to the performAction() method, then invoked the accept() method after the action was finished."}),"\n",(0,t.jsx)(n.p,{children:"You might also notice that using an anonymous inner class is quite verbose. It would be much better to use a lambda instead. Let's see what happens when we use the lambda for our callback function."}),"\n",(0,t.jsx)(n.h3,{id:"lambda-callback",children:"Lambda callback"}),"\n",(0,t.jsx)(n.p,{children:"In Java, we can implement the functional interface with a lambda expression and pass it to a method,\nthen execute the function after an operation is finished. Here's how that looks in code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class LambdaCallback {\n\n  public static void main(String[] args) {\n    performAction(() -> System.out.println("Callback function executed..."));\n  }\n\n  public static void performAction(Runnable runnable) {\n    System.out.println("Action is being performed...");\n    runnable.run();\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example, you might notice that we passed the Runnable functional interface in the performAction method. Therefore,\nwe were able to override and execute the run() method after the action from the performAction method was finished."}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-callbacks",children:"Asynchronous callbacks"}),"\n",(0,t.jsx)(n.p,{children:"Often, we want to use an asynchronous callback method, which means a method that will be invoked after the action but asynchronously with other processes.\nThat might help in performance when the callback method does not need to be invoked immediately following the other process."}),"\n",(0,t.jsx)(n.h3,{id:"simple-thread-callback",children:"Simple thread callback"}),"\n",(0,t.jsx)(n.p,{children:"Let's start with the simplest way we can make this asynchronous callback call operation.\nIn the following code, first we will implement the run() method from a Runnable functional interface.\nThen, we will create a Thread and use the run() method we've just implemented within the Thread.\nFinally, we will start the Thread to execute asynchronously:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class AsynchronousCallback {\n\n  public static void main(String[] args) {\n    Runnable runnable = () -> System.out.println("Callback executed...");\n    AsynchronousCallback asynchronousCallback = new AsynchronousCallback();\n    asynchronousCallback.performAsynchronousAction(runnable);\n  }\n\n  public void performAsynchronousAction(Runnable runnable) {\n    new Thread(() -> {\n      System.out.println("Processing Asynchronous Task...");\n      runnable.run();\n    }).start();\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"output-1",children:"Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Processing Asynchronous Task...\n\nCallback executed...\n"})}),"\n",(0,t.jsx)(n.p,{children:"Notice in the code above that first we created an implementation for the run() method from Runnable. Then, we invoked the performAsynchronousAction() method, passing the runnable functional interface with the run() method implementation."}),"\n",(0,t.jsx)(n.p,{children:'Within the performAsynchronousAction() we pass the runnable interface and implement the other Runnable interface inside the Thread with a lambda.\nThen we print "Processing Asynchronous Task\u2026" Finally, we invoke the callback function run that we passed by parameter, printing "Callback executed\u2026"'}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-parallel-callback",children:"Asynchronous parallel callback"}),"\n",(0,t.jsx)(n.p,{children:"Other than invoking the callback function within the asynchronous operation, we could also invoke a callback function in parallel with another function. This means that we could start two threads and invoke those methods in parallel."}),"\n",(0,t.jsx)(n.p,{children:"The code will be similar to the previous example but notice that instead of invoking the callback function directly we will start a new thread and invoke the callback function within this new thread:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Omitted code from above\u2026\npublic void performAsynchronousAction(Runnable runnable) {\n\n    new Thread(() -> {\n      System.out.println("Processing Asynchronous Task...");\n      new Thread(runnable).start();\n    }).start();\n  }\n'})}),"\n",(0,t.jsx)(n.h4,{id:"output-2",children:"Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Processing Asynchronous Task...\n\nCallback executed...\n"})}),"\n",(0,t.jsx)(n.p,{children:"The asynchronous parallel callback is useful when we don't need the callback function to be executed immediately after the action from the performAsynchronousAction() method."}),"\n",(0,t.jsx)(n.p,{children:"A real-world example would be when we purchase a product online and we don't need to wait until the payment is confirmed, the stock being checked, and all those heavy loading processes. In that case, we can do other things while the callback invocation is executed in the background."}),"\n",(0,t.jsx)(n.h3,{id:"completablefuture-callback",children:"CompletableFuture callback"}),"\n",(0,t.jsx)(n.p,{children:"Another way to use an asynchronous callback function is to use the CompletableFuture API. This powerful API, introduced in Java 8, facilitates executing and combining asynchronous method invocations. It does everything we did in the previous example such as creating a new Thread then starting and managing it."}),"\n",(0,t.jsx)(n.p,{children:"In the following code example we will create a new CompletableFuture, then we'll invoke the supplyAsync method passing a String."}),"\n",(0,t.jsx)(n.p,{children:"Next, we will create another ,CompletableFuture that will thenApply a callback function to execute with the first function we configured:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.CompletableFuture;\n\npublic class CompletableFutureCallback {\n\n  public static void main(String[] args) throws Exception {\n    CompletableFuture<String> completableFuture\n        = CompletableFuture.supplyAsync(() -> "Supply Async...");\n\n    CompletableFuture<String> execution = completableFuture\n        .thenApply(s -> s + " Callback executed...");\n\n    System.out.println(execution.get());\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"output-3",children:"Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Supply Async... Callback executed\u2026\n"})}),"\n",(0,t.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"Callbacks are everywhere in software development, vastly used in tools, design patterns, and in applications. Sometimes we use them without even noticing it."}),"\n",(0,t.jsx)(n.p,{children:"We've gone through a variety of common callback implementations to help demonstrate their utility and versatility in Java code. Here are some features of callbacks to remember:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A callback function is supposed to be executed either when another action is executed or in parallel to that action."}),"\n",(0,t.jsx)(n.li,{children:"A callback function can be synchronous, meaning that it must be executed right after the other action without any delay."}),"\n",(0,t.jsx)(n.li,{children:"A callback function can be asynchronous, meaning that it can be executed in the background and may take some time until it's executed.\nThe Observable design pattern uses a callback to notify interested entities when an action has happened."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var t=a(6540);const c={},l=t.createContext(c);function i(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);